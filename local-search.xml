<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>移动端脱壳分析</title>
    <link href="/2023/10/16/TencentGameClient/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%84%B1%E5%A3%B3%E5%88%86%E6%9E%90/"/>
    <url>/2023/10/16/TencentGameClient/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%84%B1%E5%A3%B3%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="DUMP脱壳"><a href="#DUMP脱壳" class="headerlink" title="DUMP脱壳"></a>DUMP脱壳</h3><p>拿到附件先file一下</p><p><img src="2023-10-16-00-53-49-image.png"></p><p>arm平台的ELF文件，因此运行和调试使用手机进行（不需要root）</p><p>ida32打开<code>CrackMe2</code>，进行静态分析</p><img title="" src="2023-10-16-00-57-58-image.png" alt="" data-align="center" width="222"><p>ida只识别出了几个函数，一眼壳，Shift+F12查看字符串，upx加壳</p><img src="2023-10-16-00-59-15-image.png" title="" alt="" width="575"><p>下载upx尝试使用<code>upx -d</code>脱壳</p><img title="" src="2023-10-16-01-00-45-image.png" alt="" width="537"><p>脱不下来，猜测upx特征被隐藏了，因此进行手动脱壳</p><p>先将<code>CrackMe2</code>push到手机，运行测试</p><img src="2023-10-16-01-05-26-image.png" title="" alt="" width="534"><p>程序在等待输入状态，此时upx已经完成解压缩，直接dump内存</p><p>启动idaserver，ida连接idaserver并附加调试</p><img title="" src="2023-10-16-01-07-40-image.png" alt="" width="427"><p>进程在read系统调用断下，根据LR寄存器定位返回地址，下断点，F9恢复进程运行</p><img src="2023-10-16-01-13-41-image.png" title="" alt="" width="426"><p>程序中随意输入字符串<code>1234567890</code>后回车，进程在断点出断下</p><img src="2023-10-16-01-14-23-image.png" title="" alt="" width="424"><p>使用Ctrl+F7运行到返回，直到PC离开libc.so内存空间，函数返回情况如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">syscall_read -&gt; __sread -&gt; __srefill -&gt; __srget -&gt; getc -&gt; debug005+<span class="hljs-number">0x9E64</span><br></code></pre></td></tr></table></figure><img src="2023-10-16-01-19-53-image.png" title="" alt="" width="419"><p>PC离开libc.so内存空间后，返回到debug005段中，因此该段为upx解压之后的可执行段，使用OllyDump插件dump该段内存，选择debug005段</p><img title="" src="2023-10-16-01-25-02-image.png" alt="" width="491"><p>OllyDump自动识别了入口点<code>0x5358</code>，以及存在关联的段，所有参数保持默认，dump为<code>Crackme2_dump.so</code></p><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>使用ida32打开<code>Crackme2_dump.so</code>，自动识别出程序入口点<code>start</code>和主函数<code>main</code></p><img src="2023-10-16-07-44-51-image.png" title="" alt="" width="497"><img title="" src="2023-10-16-07-46-21-image.png" alt="" width="493"><p>在main函数中，显然0x6E2C处为输出提示字符串，Shift+F12查看字符串，定位到如下可能有用的字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">LOAD:<span class="hljs-number">00048000</span> aCatProcNetTcpG DCB <span class="hljs-string">&quot;cat /proc/net/tcp |grep :5D8A&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">0004801</span>E aR DCB <span class="hljs-string">&quot;r&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048020</span> aProcDStatus DCB <span class="hljs-string">&quot;/proc/%d/status&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048030</span> aTracerpid DCB <span class="hljs-string">&quot;TracerPid&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">0004803</span>A aUndebug DCB <span class="hljs-string">&quot;undebug&quot;</span>,<span class="hljs-number">0xA</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048050</span> aDmd2vxkydlvezu DCB <span class="hljs-string">&quot;DMD2vxKYDLvezuriqND2DhP3BJfdtuWWrxe9pq==&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048079</span> aWrongAnswer DCB <span class="hljs-string">&quot;Wrong Answer&quot;</span>,<span class="hljs-number">0xA</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048090</span> aInputYourAnswe DCB <span class="hljs-string">&quot;Input Your Answer:&quot;</span>,<span class="hljs-number">0xA</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">000480B</span>0 aJustForKidding DCB <span class="hljs-string">&quot;just for kidding&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048120</span> aAbcdefghijklmn DCB <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048140</span> aAbcdefghijklmn_0 DCB <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048160</span> a0123456789 DCB <span class="hljs-string">&quot;0123456789+/&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">0004816</span>D aTrueAnswer DCB <span class="hljs-string">&quot;True Answer&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048179</span> aWrongAnswer_0 DCB <span class="hljs-string">&quot;Wrong Answer&quot;</span>,<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h5><p>第一个可疑字符串<code>cat /proc/net/tcp |grep :5D8A</code>查看当前的TCP连接情况，<code>0x5D8A</code>转换为十进制为<code>23946</code>，idaserver的默认调试端口，因此此处为检查端口的反调试，查看交叉引用定位到反调试代码</p><p>定位到反调试函数的地址为<code>0x53F4</code>，命名为<code>undebug1</code></p><p>第二个可疑字符串<code>/proc/%d/status</code>，查看进程的状态，根据后续的字符串<code>TracerPid</code>猜测该处是检查进程的<code>TracerPid</code>判断进程是否被调试，查看交叉引用定位到反调试代码</p><img src="2023-10-16-08-05-43-image.png" title="" alt="" width="453"><p>定位到反调试函数地址为<code>0x059D4</code>，命名为<code>undebug2</code></p><p>第三个字符串<code>undebug</code>，是检测到调试器时的输出字符串，查看交叉定位输出该字符串的位置</p><img src="2023-10-16-12-39-09-image.png" title="" alt="" width="455"><p>定位到函数地址为<code>0x5AD0</code>，命名为<code>undebug</code>，该函数调用<code>undebug1</code>和<code>undebug2</code>检测是否被调试，由于<code>undebuge1</code>和<code>undebug2</code>中均没有使程序终止的代码，因此检查调试的入口点为<code>undebug</code></p><h5 id="输入校验"><a href="#输入校验" class="headerlink" title="输入校验"></a>输入校验</h5><p>注意到字符串<code>DMD2vxKYDLvezuriqND2DhP3BJfdtuWWrxe9pq==</code>，典型的base64字符串，尝试解码但发现乱码，猜测解码后的数据为二进制数据或base64码表被替换</p><img src="2023-10-16-12-43-00-image.png" title="" alt="" width="458"><p><code>True Answer</code>应该是输入字符串正确时的输出，根据其交叉引用定位到输出该字符串的位置</p><p>定位到<code>0x7B50</code>函数处，将其命名位<code>check</code></p><img src="2023-10-16-12-53-49-image.png" title="" alt="" width="545"><p>两个分支分别输出<code>Wrong Answer</code>和<code>True Answer</code>，查看该函数的反编译代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c">v6 = <span class="hljs-number">0</span>;<br>v52 = *(_DWORD *)off_47CE8;<br>*a1 = <span class="hljs-number">0</span>;<br>a1[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>a1[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> ( a3 )<br>&#123;<br>    LOBYTE(v41) = v46;<br>    LOBYTE(v7) = v45;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>    v8 = *a2++;<br>    --a3;<br>    *(&amp;v49 + v6++) = v8;<br>    <span class="hljs-keyword">if</span> ( v6 == <span class="hljs-number">3</span> )<br>    &#123;<br>        v9 = v49;<br>        v10 = v51 &amp; <span class="hljs-number">0x3F</span>;<br>        v11 = v50;<br>        v12 = (<span class="hljs-type">char</span> *)dword_48230;<br>        v13 = (v51 &gt;&gt; <span class="hljs-number">6</span>) &amp; <span class="hljs-number">0xFFFFFFC3</span> | (<span class="hljs-number">4</span> * (v50 &amp; <span class="hljs-number">0xF</span>));<br>        v47 = (v51 &gt;&gt; <span class="hljs-number">6</span>) &amp; <span class="hljs-number">0xC3</span> | (<span class="hljs-number">4</span> * (v50 &amp; <span class="hljs-number">0xF</span>));<br>        v48 = v51 &amp; <span class="hljs-number">0x3F</span>;<br>        <span class="hljs-keyword">if</span> ( (byte_48228 &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> )<br>        v12 = algn_48229;<br>        v43 = a3;<br>        v42 = a2;<br>        sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v12[v49 &gt;&gt; <span class="hljs-number">2</span>]);<br>        v14 = (<span class="hljs-type">char</span> *)dword_48230;<br>        <span class="hljs-keyword">if</span> ( (byte_48228 &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> )<br>        v14 = algn_48229;<br>        v41 = (<span class="hljs-number">16</span> * v9) &amp; <span class="hljs-number">0x30</span> | (v11 &gt;&gt; <span class="hljs-number">4</span>);<br>        sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v14[v41]);<br>        v15 = (<span class="hljs-type">char</span> *)dword_48230;<br>        <span class="hljs-keyword">if</span> ( (byte_48228 &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> )<br>        v15 = algn_48229;<br>        sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v15[v13]);<br>        v16 = (<span class="hljs-type">char</span> *)dword_48230;<br>        <span class="hljs-keyword">if</span> ( (byte_48228 &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> )<br>        v16 = algn_48229;<br>        sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v16[v10]);<br>        v7 = v9 &gt;&gt; <span class="hljs-number">2</span>;<br>        a2 = v42;<br>        v6 = <span class="hljs-number">0</span>;<br>        a3 = v43;<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> ( a3 );<br>    v45 = v7;<br>    v46 = v41;<br>    <span class="hljs-keyword">if</span> ( v6 )<br>    &#123;<br>    <span class="hljs-keyword">if</span> ( v6 &lt;= <span class="hljs-number">2</span> )<br>        <span class="hljs-built_in">memset</span>(&amp;v49 + v6, <span class="hljs-number">0</span>, <span class="hljs-number">3</span> - v6);<br>    v45 = v49 &gt;&gt; <span class="hljs-number">2</span>;<br>    v46 = (<span class="hljs-number">16</span> * v49) &amp; <span class="hljs-number">0x30</span> | (v50 &gt;&gt; <span class="hljs-number">4</span>);<br>    v47 = (v51 &gt;&gt; <span class="hljs-number">6</span>) &amp; <span class="hljs-number">0xC3</span> | (<span class="hljs-number">4</span> * (v50 &amp; <span class="hljs-number">0xF</span>));<br>    v48 = v51 &amp; <span class="hljs-number">0x3F</span>;<br>    <span class="hljs-keyword">if</span> ( v6 &gt;= <span class="hljs-number">0</span> )<br>    &#123;<br>        v17 = (<span class="hljs-type">char</span> *)dword_48230;<br>        <span class="hljs-keyword">if</span> ( (byte_48228 &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> )<br>        v17 = algn_48229;<br>        sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v17[v49 &gt;&gt; <span class="hljs-number">2</span>]);<br>        v18 = v6;<br>        v19 = &amp;v46;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>        v20 = (<span class="hljs-type">char</span> *)dword_48230;<br>        v22 = (<span class="hljs-type">unsigned</span> __int8)*v19++;<br>        v21 = v22;<br>        <span class="hljs-keyword">if</span> ( (byte_48228 &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> )<br>            v20 = algn_48229;<br>        sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v20[v21]);<br>        --v18;<br>        &#125;<br>        <span class="hljs-keyword">while</span> ( v18 );<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( v6 &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        v23 = <span class="hljs-number">3</span> - v6;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>        sub_8430(a1, <span class="hljs-number">61</span>);<br>        --v23;<br>        &#125;<br>        <span class="hljs-keyword">while</span> ( v23 );<br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到该if内有明显的base64编码特征</p><p>每次从a2中取出三个字符，依次存放在v49, v50, v51中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span><br>&#123;<br>    v8 = *a2++;<br>    --a3;<br>    *(&amp;v49 + v6++) = v8;<br>    <span class="hljs-keyword">if</span> ( v6 == <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-comment">/******/</span><br>        v6 = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">while</span> ( a3 );<br></code></pre></td></tr></table></figure><p>对第一个字符取高6位作为索引查表，然后由<code>sub_8430</code>处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v12[v49 &gt;&gt; <span class="hljs-number">2</span>]);<br></code></pre></td></tr></table></figure><p>对第一个字符取低两位，第二个字符取高4位，组合为6位，作为索引查表，然后由<code>sub_8430</code>处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">v9 = v49;<br>v11 = v50;<br>v41 = (<span class="hljs-number">16</span> * v9) &amp; <span class="hljs-number">0x30</span> | (v11 &gt;&gt; <span class="hljs-number">4</span>);<br>sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v14[v41]);<br></code></pre></td></tr></table></figure><p>对第二个字符取低4位，第三个字符取高两位，组合为6位，作为索引查表，然后由<code>sub_8430</code>处理 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">v13 = (v51 &gt;&gt; <span class="hljs-number">6</span>) &amp; <span class="hljs-number">0xFFFFFFC3</span> | (<span class="hljs-number">4</span> * (v50 &amp; <span class="hljs-number">0xF</span>));<br>sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v15[v13]);<br></code></pre></td></tr></table></figure><p>对第三个字符取低6位，作为索引查表，然后由<code>sub_8430</code>处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">v10 = v51 &amp; <span class="hljs-number">0x3F</span>;<br>sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v16[v10]);<br></code></pre></td></tr></table></figure><p>后续不足3个字符的一次此处省略分析，分析发现存在两个关键点，一是base64编码的码表<code>(char *)dword_48230</code>，二是<code>sub_8430</code>函数</p><p>base64编码结束的地址为<code>0x7D84</code></p><p><code>0x48230</code>储存的是码表的地址，未在dump的文件中，后续动态调试时分析</p><p><code>0x8430</code>处函数较为复杂，但是由于其输入简单，因此考虑在动态调试时分析</p><p>上述代码对参数字符串a2使用base64编码，分析<code>check</code>函数剩余代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">v24 = *(<span class="hljs-type">unsigned</span> __int8 *)a1;<br>v25 = a1[<span class="hljs-number">1</span>];<br>v26 = *a4;<br>v27 = *((_DWORD *)a4 + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> ( (v26 &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span> )<br>    v27 = v26 &gt;&gt; <span class="hljs-number">1</span>;<br>v28 = v24 &amp; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> ( (v24 &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> )<br>    v25 = v24 &gt;&gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>在<code>check</code>函数开始时，<code>a1[0], a1[1], a1[2]</code>均被设为0，但a1作为<code>sub_8430</code>参数，多次参入base64编码的过程，且在最后的判断中，多个值从<code>a1</code>处读取，猜测<code>a1</code>处可能储存base64编码的结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( v27 )<br>&#123;<br>    v32 = -(v26 &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> ( *v31 == *v29 )<br>    &#123;<br>    ++v32;<br>    ++v29;<br>    ++v31;<br>    <span class="hljs-keyword">if</span> ( !v32 )<br>        <span class="hljs-keyword">goto</span> LABEL_43;<br>    &#125;<br>    <span class="hljs-keyword">goto</span> LABEL_42;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码进行字符串比较，关键判断</p><h5 id="动态调试分析"><a href="#动态调试分析" class="headerlink" title="动态调试分析"></a>动态调试分析</h5><p>根据上述动态调试分析，获得以下需要断点的位置</p><ul><li><p>getc返回地址<code>debug005+0x9E64</code></p><blockquote><p>getc处为Thumb模式，需要使用Alt+g将Thumb标准设为1进行解析</p></blockquote></li><li><p>undebug反调试函数<code>debug005+0x5AD0</code></p></li><li><p>check函数<code>debug005+0x7B50</code></p></li><li><p>base64编码结束位置<code>debug005+0x7D84</code></p></li></ul><p>需要重点分析的内存区域有：</p><ul><li><p>check函数参数寄存器<code>R0</code></p></li><li><p>check函数参数寄存器<code>R3</code></p></li><li><p>base64编码码表<code>debug005+0x48230</code></p></li></ul><p>由于dump得到的elf文件中部分地址存储的值错误，不能之间进行运行调试，因此继续对<code>CrackMe2</code>进行附加调试</p><p>按照dump过程进行附加调试，进程断下后对上述地址下断点恢复运行，随意输入字符串<code>1234567890</code></p><p>getc返回位置断下</p><img src="2023-10-16-14-07-28-image.png" title="" alt="" width="494"><p>取消断点，F9继续运行，undebug函数断下</p><img src="2023-10-16-14-09-26-image.png" title="" alt="" width="495"><p>手动将PC设到LR寄存器指向的返回地址处</p><img src="2023-10-16-14-10-33-image.png" title="" alt="" width="497"><p>F9继续运行</p><img src="2023-10-16-14-11-12-image.png" title="" alt="" width="499"><p>check函数断下，寄存器如下</p><img src="2023-10-16-16-39-43-image.png" title="" alt="" width="274"><p>记录R0寄存器的值<code>0xFFBAA758</code></p><p>查看R1地址处（a2参数），很明显为输入的字符串</p><img src="2023-10-16-16-40-18-image.png" title="" alt="" width="496"><p>R2的值（a3参数）为<code>0xA</code>，很明显为输入字符串的长度</p><p>查看R3地址处(a4参数)，<code>0x21</code></p><img src="2023-10-16-16-40-50-image.png" title="" alt="" width="493"><p>查看base64编码码表<code>debug005+0x48230</code></p><img src="2023-10-16-16-42-09-image.png" title="" alt="" width="491"><img title="" src="2023-10-16-16-43-31-image.png" alt="" width="486"><p>注意到该码表与标准base64码表不同，标准base64大写字母在前，小写字母在后，而此处相反，因此经过编码后的字符串大小写与标准base64编码相反</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> string<br><br>str1 = <span class="hljs-string">&quot;1234567890&quot;</span><br><br>alpha_table = <span class="hljs-string">&quot;\</span><br><span class="hljs-string">ABCDEFGHIJKLMNOPQRSTUVWXYZ\</span><br><span class="hljs-string">abcdefghijklmnopqrstuvwxyz\</span><br><span class="hljs-string">0123456789+/&quot;</span><br>alpha_table2 = <span class="hljs-string">&quot;\</span><br><span class="hljs-string">abcdefghijklmnopqrstuvwxyz\</span><br><span class="hljs-string">ABCDEFGHIJKLMNOPQRSTUVWXYZ\</span><br><span class="hljs-string">0123456789+/&quot;</span><br>trans = str1.maketrans(alpha_table, alpha_table2)<br><br>str1_b64 = base64.b64encode(str1.encode()).decode()<br>str1_b64_2 = str1_b64.translate(trans)<br><span class="hljs-built_in">print</span>(str1_b64)<br><span class="hljs-comment"># MTIzNDU2Nzg5MA==</span><br><span class="hljs-built_in">print</span>(str1_b64_2)<br><span class="hljs-comment"># mtiZndu2nZG5ma==</span><br></code></pre></td></tr></table></figure><p>F9运行到对输入字符串base64编码完成处<code>debug005+0x7D84</code>，查看之前记录的R0中地址处内容<code>0xFFBAA758</code></p><img src="2023-10-16-16-48-38-image.png" title="" alt="" width="492"><p>第一个值为<code>0x21</code>，根据前面的分析，可能是待比较的数据长度，第二个值为<code>0x10</code>，可能为输入字符串编码后的长度，第三个值为地址<code>0xF67450A0</code>，查看该地址处内存</p><img src="2023-10-16-17-07-13-image.png" title="" alt="" width="494"><p>地址处的值为输入字符串编码后的b64字符串<code>mtiZndu2nZG5ma==</code>，与上述测试相同，该地址<code>-0x20</code>处为另一个b64字符串<code>vgvUy2vUDeDHBwvtzwn1CML0Eq==</code>，猜测为待比较的字符串，使用base64解码测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">str2_b64 = <span class="hljs-string">&quot;vgvUy2vUDeDHBwvtzwn1CML0Eq==&quot;</span><br>str2_b64_2 = str2_b64.translate(trans)<br>str2 = base64.b64decode(str2_b64_2.encode()).decode()<br><span class="hljs-built_in">print</span>(str2)<br><span class="hljs-comment"># TencentGameSecurity</span><br></code></pre></td></tr></table></figure><p>解码得到字符串<code>TencentGameSecurity</code>，猜测可能为flag</p><p>ida继续调试，运行到第一个判断分枝</p><img src="2023-10-16-17-15-14-image.png" title="" alt="" width="502"><p>此时R2为<code>0x1C</code>，<code>vgvUy2vUDeDHBwvtzwn1CML0Eq==</code>字符串的长度</p><p>R0为<code>0x10</code>，<code>mtiZndu2nZG5ma==</code>字符串的长度</p><p>当两个字符串长度不相等时，跳转到输出<code>Wrong Answer</code>，手动修改R0寄存器为<code>0x1C</code>，跳过该判断</p><img src="2023-10-16-17-20-17-image.png" title="" alt="" width="509"><p>运行到第二个分枝，仍然手动跳过</p><img src="2023-10-16-17-24-37-image.png" title="" alt="" width="507"><p>运行到循环进行比较的位置，比较R1和R3处字符串是否相等</p><img src="2023-10-16-17-25-54-image.png" title="" alt="" width="286"><p>查看寄存器发现R1指向字符串<code>mtiZndu2nZG5ma==</code>，但R3未指向另一字符串，猜测在手动跳转时可能导致寄存器改变错误</p><p>中断进程，对上述得到的疑似flag<code>TencentGameSecurity</code>进行测试</p><img src="2023-10-16-17-34-27-image.png" title="" alt="" width="582"><p><code>Trun Answer</code>，说明确实是正确的flag</p><p>静态分析时得到一个使用base64解码乱码的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">LOAD:00048050 aDmd2vxkydlvezu DCB <span class="hljs-string">&quot;DMD2vxKYDLvezuriqND2DhP3BJfdtuWWrxe9pq==&quot;</span>,<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>猜测其编码码表被替换，对其重新解码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">str3_b64 = <span class="hljs-string">&quot;DMD2vxKYDLvezuriqND2DhP3BJfdtuWWrxe9pq==&quot;</span><br>str3_b64_2 = str3_b64.translate(trans)<br>str3 = base64.b64decode(str3_b64_2.encode()).decode()<br><span class="hljs-built_in">print</span>(str3)<br><span class="hljs-comment"># vgvUy2vUDeDHBwvtzwn1CML0Eq==</span><br></code></pre></td></tr></table></figure><p>解码出来的字符串是<code>vgvUy2vUDeDHBwvtzwn1CML0Eq==</code>，再解码一次就是flag<code>TencentGameSecurity</code></p><h3 id="upx-d脱壳"><a href="#upx-d脱壳" class="headerlink" title="upx -d脱壳"></a>upx -d脱壳</h3><p>经过调试解压缩过程，发现该壳明显就是原版的upx,无法直接<code>upx -d</code>说明修改了，特征字段，编译一个测试文件进行加壳对照分析</p><p>使用010editor打开<code>CrackMe2</code>和对照文件，两个文件都为3个节区，理论上每个节区都存在<code>UPX!</code>关键字，搜索关键字<code>UPX!</code></p><img src="2023-10-16-17-40-06-image.png" title="" alt="" width="451"><img src="2023-10-16-17-40-29-image.png" title="" alt="" width="453"><p>发现<code>CrackMe2</code>只搜索到3个<code>UPX!</code>关键字，而对照文件有4个，对照文件中4个<code>UPX!</code>第一个分布在文件开始位置不远处，第二个位于中间位置，后两个位于文件末尾，并且后两个距离很近，而<code>CrackMe2</code>末尾处只有两个<code>UPX!</code>关键字</p><p>定位到文件末尾</p><img src="2023-10-16-17-44-28-image.png" title="" alt="" width="456"><img src="2023-10-16-17-44-55-image.png" title="" alt="" width="460"><p>将<code>CrackMe2</code>对应位置处修改为<code>UPX!</code></p><img src="2023-10-16-17-45-59-image.png" title="" alt="" width="466"><p>保存文件使用<code>upx -d</code>脱壳</p><img src="2023-10-16-17-47-27-image.png" title="" alt="" width="464"><p>脱壳成功，使用ida打开脱壳文件分析</p><img src="2023-10-16-17-48-51-image.png" title="" alt="" width="474"><img src="2023-10-16-17-49-54-image.png" title="" alt="" width="478"><p>程序的函数以及代码都能够正常分析，但是字符串未正常解析，无法快速定位，根据之前的分析可以知道字符串是在程序运行时解码生成的</p><p>尝试运行脱壳后的文件</p><img src="2023-10-16-17-52-38-image.png" title="" alt="" width="482"><p>能够正常运行，输入flag<code>TencentGameSecurity</code>后能够正确判断</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>01关于逆向工程</title>
    <link href="/2023/10/12/reverse_core/01%E5%85%B3%E4%BA%8E%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <url>/2023/10/12/reverse_core/01%E5%85%B3%E4%BA%8E%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>逆向工程核心原理一书非常适合逆向初学者进行学习，该书以Windows x86为平台，详细介绍了逆向中的调试分析技巧</p><p>本系列文章将对书籍中的内容进行记录</p></blockquote><h3 id="逆向工程常用分析方法"><a href="#逆向工程常用分析方法" class="headerlink" title="逆向工程常用分析方法"></a>逆向工程常用分析方法</h3><ul><li><p>静态分析</p><p>在不执行代码文件的情形下，对大妈进行静态分析，观察代码文件的外部特征，通常会查看文件的类型、大小、PE头信息、导入导出表、字符串等信息。此外还会使用反汇编和反编译工具查看内部代码、分析代码结构。</p></li><li><p>动态分析</p><p>动态分析是在程序文件执行过程中对代码进行分析、通过动态调试来分析代码流，获取内存状态等，动态分析常使用调试器分析程序的内部结构和动作原理。</p></li></ul><p>在逆向分析程序时，通常静态分析与动态分析相互结合，在静态分析的过程中猜测代码的功能，对存在分析价值的代码下断点、快速跳过不重要的代码，提高动态分析的效率，在动态分析时对静态分析时的猜测进行验证，确保分析的准确性。</p><h3 id="逆向的准备"><a href="#逆向的准备" class="headerlink" title="逆向的准备"></a>逆向的准备</h3><ul><li><p>C语言</p><p>在进行逆向分析时，需要能够揣测开发者的开发思路、对常见的代码结构有所了解，因此需要具备正向开发的基础</p></li><li><p>汇编语言</p><p>在逆向分析时，虽然可以使用IDA将汇编代码反编译为C代码，但是反编译的代码在大多数情况下存在错误，并且并非所有情况都能将汇编代码进行反编译，因此需要对汇编指令有较多的了解、了解汇编中分支调整、函数调用等过程，能够根据汇编代码还原程序的逻辑</p></li><li><p>兴趣和大量的时间</p><p>首先需要了解自己为什么要学习逆向分析技术，如果只是以破解游戏软件为目的，并不建议系统学习逆向分析技术。</p><p>逆向分析是一个及其耗费时间的过程，需要有足够得耐心。</p><blockquote><p>学习代码逆向分析技术的过程中，有时候会遇到挫折，让人感到厌倦，这可能会让我们暂停学习。不过，只要保持对逆向分析技术的激情，我们就不会放弃，而会再次挑战。通过一次又一次得尝试，我们最终会成为代码逆向分析专家。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>逆向工程核心原理二周目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游戏客户端开发基础-移动篇</title>
    <link href="/2023/10/09/TencentGameClient/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-%E7%A7%BB%E5%8A%A8%E7%AF%87/"/>
    <url>/2023/10/09/TencentGameClient/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-%E7%A7%BB%E5%8A%A8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/noxke/TencentGameClientOpenCourse">GitHub - noxke&#x2F;TencentGameClientOpenCourse: 腾讯游戏客户端公开课2023 腾讯菁英班</a></p><h3 id="1-Java层分析"><a href="#1-Java层分析" class="headerlink" title="1.Java层分析"></a>1.Java层分析</h3><p>使用jadx打开题目apk，查看AndroidManifest.xml获取程序入口Activity为<code>com.example.crackme1.MainActivity</code></p><p>查看反编译的<code>MainActivity</code>类的<code>onCreate</code>方法，分析Java层逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>    <span class="hljs-type">ActivityMainBinding</span> <span class="hljs-variable">inflate</span> <span class="hljs-operator">=</span> ActivityMainBinding.inflate(getLayoutInflater());<br>    <span class="hljs-built_in">this</span>.binding = inflate;<br>    setContentView(inflate.getRoot());<br>    <span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> (Button) findViewById(C0462R.C0465id.button);<br>    <span class="hljs-built_in">this</span>.btn1 = button;<br>    button.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123; <span class="hljs-comment">// from class: com.example.crackme1.MainActivity.1</span><br>        <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.view.View.OnClickListener</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>            <span class="hljs-type">EditText</span> <span class="hljs-variable">textInput</span> <span class="hljs-operator">=</span> (EditText) MainActivity.<span class="hljs-built_in">this</span>.findViewById(C0462R.C0465id.TextInput);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">Inputstr</span> <span class="hljs-operator">=</span> textInput.getText().toString();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">RetStr</span> <span class="hljs-operator">=</span> MainActivity.<span class="hljs-built_in">this</span>.stringFromJNI(Inputstr);<br>            Toast.makeText(MainActivity.<span class="hljs-built_in">this</span>, RetStr, <span class="hljs-number">0</span>).show();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>按钮触发点击事件后，调用<code>onClick</code>方法，获取输入框的输入字符串<code>Inputstr</code>，将输入字符串<code>Inputstr</code>调用<code>stringFromJNI</code>方法，并将返回字符串<code>RetStr</code>显示为toast消息</p><p>查看处理字符串的<code>stringFromJNI</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> String <span class="hljs-title function_">stringFromJNI</span><span class="hljs-params">(String str)</span>;<br><br><span class="hljs-keyword">static</span> &#123;<br>    System.loadLibrary(<span class="hljs-string">&quot;crackme1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法为native文件<code>libcrackme1.so</code>中的导出函数</p><p>使用Android Studio打开apk文件进行调试，对<code>onClick</code>方法中的<code>stringFromJNI</code>调用行下断点，开始调试运行</p><p><img src="2023-10-09-11-15-05-image.png"></p><p><img src="2023-10-09-11-15-22-image.png"></p><p>调用<code>stringFromJNI</code>前，参数寄存器v0为输入的字符串，单步跳过该行调用，查看返回值</p><p><img src="2023-10-09-11-17-23-image.png"></p><p>返回值v2寄存器为字符串<code>Wrong</code>，继续运行程序，字符串<code>wrong</code>以toast消息显示在屏幕上</p><p><img src="2023-10-09-11-18-57-image.png"></p><p><img src="2023-10-09-11-19-20-image.png"></p><p>查看logcat发现，调用<code>stringFromJNI</code>函数时程序会打印log信息<code>Str:...</code>，并且每次点击按钮调用函数时打印的字符串均不相同</p><h3 id="2-Native层分析"><a href="#2-Native层分析" class="headerlink" title="2.Native层分析"></a>2.Native层分析</h3><p>分析和调试Java层发现，程序的字符串校验功能位于native层的<code>stringFromJNI</code>函数中，该函数为<code>libcrackme1.so</code>动态库的导出函数，该库文件位于<code>crackme1/lib/armeabi-v7a/</code>目录下，因此程序需要使用支持armabi-v7a的设备运行</p><p>使用readelf工具查看<code>libcrackme1.so</code>的导出函数</p><p><img src="2023-10-09-11-27-47-image.png"></p><p><code>stringFromJNI</code>函数偏移地址为<code>0x1194</code>，函数偏移最低位为0，Arm模式执行</p><p>使用ida32打开<code>libcrackme1.so</code>文件查看<code>stringFromJNI</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __fastcall <span class="hljs-title function_">Java_com_example_crackme1_MainActivity_stringFromJNI</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2, <span class="hljs-type">int</span> a3)</span><br>&#123;<br>  <span class="hljs-type">char</span> *s2; <span class="hljs-comment">// [sp+Ch] [bp-7Ch]</span><br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [sp+20h] [bp-68h] BYREF</span><br><br>  s2 = (<span class="hljs-type">char</span> *)sub_12A4(a1, a3, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">memset</span>(s, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(s));<br>  qmemcpy(s, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">3</span>);<br>  sub_F50(<span class="hljs-number">5</span>, s);<br>  <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strncmp</span>(s, s2, <span class="hljs-number">5u</span>) || (sub_1134() &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span> )<br>    <span class="hljs-keyword">return</span> sub_12EC(a1, <span class="hljs-string">&quot;right&quot;</span>);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> sub_12EC(a1, <span class="hljs-string">&quot;wrong&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据反编译c代码，函数将输入字符串<code>s2</code>与<code>sub_F50</code>函数生成的字符串s进行比较，当比较结果相同时，返回字符串<code>right</code>，不同时返回结果<code>wrong</code></p><p>查看<code>sub_F50</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __fastcall <span class="hljs-title function_">sub_F50</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *a2)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v2; <span class="hljs-comment">// r0</span><br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// r1</span><br>  <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [sp+8h] [bp-28h]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [sp+14h] [bp-1Ch]</span><br>  <span class="hljs-type">size_t</span> v9; <span class="hljs-comment">// [sp+2Ch] [bp-4h]</span><br><br>  v2 = time(<span class="hljs-number">0</span>);<br>  srand(v2);<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; a1; ++i )<br>  &#123;<br>    v5 = rand();<br>    v9 = _strlen_chk(a0123456789abcd, <span class="hljs-number">0x40</span>u);<br>    sub_2964(v5, v9);<br>    a2[i] = a0123456789abcd[v3];<br>  &#125;<br>  a2[i] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> _android_log_print(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Crack&quot;</span>, <span class="hljs-string">&quot;Str:%s&quot;</span>, a2);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数生成一个随机字符串，并在log中打印该字符串，因此在log中看到的<code>Str:...</code>就是进行比较的字符串</p><p>在if判断中，除了比较字符串是否相等，还对<code>sub_1134</code>函数返回值进行判断，分析该函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sub_1134</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img title="" src="2023-10-09-12-09-13-image.png" alt="" width="475"><p>反编译的c代码中该函数直接返回0,但根据汇编代码，该函数内存在打印log信息的函数调用，提示<code>hook this func to return true</code>，但该分支永远不会执行，因此logcat中未查看到该log信息，按照提示，后续选择该函数进行hook，其偏移地址为<code>0x1134</code>，后续称为<code>proc</code>，函数偏移地址最低为为0，Arm模式执行</p><p>查看<code>/proc/pid/maps</code>文件查看<code>libcrackme1.so</code>内存映射信息</p><p><img src="2023-10-09-12-23-02-image.png"></p><p><code>libcrackme1.so</code>的加载基地址为<code>0xe36f0000</code>，因此<code>stringFromJNI</code>函数在内存中的地址为<code>0xe36f1194</code></p><p>ida对<code>stringFromJNI</code>和<code>proc</code>下断点，附加到<code>com.example.crackme1</code>进程进行调试</p><p>调试器附加后发现线程13032触发了SIGABRT信号，导致程序中断，如果继续运行程序将信号传送给进程，程序会崩溃无法调试，该处需要将对产生该信号的线程挂起，并忽略该信号避免该线程恢复运行</p><img src="2023-10-09-12-16-24-image.png" title="" alt="" width="290"><img src="2023-10-09-12-16-40-image.png" title="" alt="" width="293"><img src="2023-10-09-12-17-08-image.png" title="" alt="" width="294"><p>在程序输入字符串点击确认按钮，Android Studio单步执行<code>stringFromJNI</code>方法，ida在<code>stringFromJNI</code>函数入口断下，函数地址为<code>0xe36f1194</code>，与上述计算相同</p><img title="" src="2023-10-09-12-24-14-image.png" alt="" width="493"><p>运行到生成随机字符串的函数返回，strcmp之前，查看两个字符串内容</p><img title="" src="2023-10-09-12-27-51-image.png" alt="" width="491"><img title="" src="2023-10-09-12-28-08-image.png" alt="" width="485"><img title="" src="2023-10-09-12-28-27-image.png" alt="" width="482"><p>分别为生成的随机字符串和输入字符串，查看log信息</p><img title="" src="2023-10-09-12-29-33-image.png" alt="" width="479"><p>log打印的字符串为函数生成的随机字符串</p><p>断点到<code>proc</code>函数</p><img title="" src="2023-10-09-12-34-04-image.png" alt="" width="479"><p>对函数的BEQ执行进行修改，使起能够打印log信息，并在函数返回时，将返回值R0寄存器修改为1</p><img title="" src="2023-10-09-12-35-36-image.png" alt="" width="477"><p>出现<code>hook this func to return true</code>log信息，继续运行程序，使<code>stringFromJNI</code>函数返回</p><p><img src="2023-10-09-12-37-39-image.png"></p><p>smali代码中<code>stringFromJNI</code>返回<code>right</code>，继续运行程序，屏幕显示toast消息<code>right</code></p><h3 id="3-ptrace注入程序"><a href="#3-ptrace注入程序" class="headerlink" title="3.ptrace注入程序"></a>3.ptrace注入程序</h3><p>使用ptrace注入程序大致分为以下几个步骤</p><ul><li><p>使用PTRACE_ATTACH附加的进程</p></li><li><p>手动调用malloc函数在进程内分配内存</p></li><li><p>使用PTRACE_WRITE将要注入的so文件路径写入进程内存</p></li><li><p>手动调用dlopen函数将so文件加载到进程内存</p></li><li><p>使用PTRACE_CONT恢复进程运行，使用PTRACE_DETACH从进程脱离</p></li></ul><p>其中需要手动调用的函数<code>malloc</code>位于<code>libc.so</code>中，函数<code>dlopen</code>位于<code>libdl.so</code>中，使用readelf查看<code>libc.so</code>和<code>libdl.so</code>的导出信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell<br>lmipro:/ $ su<br>lmipro:/ # readelf -s -W /apex/com.android.runtime/lib/bionic/libc.so |\<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">grep malloc</span><br>   536: 0002d685    76 FUNC    GLOBAL DEFAULT   17 malloc<br><br>lmipro:/ # readelf -s -W /apex/com.android.runtime/lib/bionic/libdl.so |\                                                                             <br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">grep dlopen</span><br>    19: 00001849    10 FUNC    WEAK   DEFAULT   10 dlopen<br></code></pre></td></tr></table></figure><p><code>malloc</code>函数的偏移地址为<code>0x2d685</code>，<code>dlopen</code>函数的编译地址为<code>0x1849</code>，注意到两个函数偏移地址最低位都是1，处理器在执行这两个函数时需要进入Thumb模式</p><blockquote><p>Armv7a处理器指令集指令长度为4字节，当处理器进入Thumb模式后，指令长度为2字节，或拓展长度为4字节，当PC跳转的目的地址指令最低为为1时，处理器需要进入Thumb模式，置CPSR寄存器第5位为1，当恢复arm模式时，置CPSR寄存器第5位为0</p><img title="" src="2023-10-09-12-56-17-image.png" alt="" width="394"><p>在c标准函数调用时，前4个参数依次存放在R0~R3寄存器中，剩余的参数从右向左依次压入栈中，返回地址存放在LR寄存器中，返回值存放在R0寄存器中</p></blockquote><p>使用ptrace手动调用函数时，需要先使用PTRACE_GETREGS保存进程的寄存器信息，然后减小SP寄存器创建栈帧，将函数参数依次存放到R0~R3寄存器中，剩余参数存放到栈中，然后根据函数地址设置PC寄存器和CPSR寄存器，PC寄存器设置为函数地址，最低位置0，根据函数地址最低位设置CPSR寄存器Thumb模式标志为，然后设置LR寄存器为0,使函数返回时，触发错误停止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// PC寄存器，低位决定处理器模式</span><br>regs.uregs[<span class="hljs-number">15</span>] = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)proc_addr &amp; <span class="hljs-number">0xFFFFFFFE</span>);<br><span class="hljs-comment">// PSR寄存器，第5位决定Thumb模式,根据函数地址最低位确定是否进入Thumb模式</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)proc_addr &amp; <span class="hljs-number">0x1</span>)<br>&#123;<br>    <span class="hljs-comment">// Thumb模式</span><br>    regs.uregs[<span class="hljs-number">16</span>] = regs.uregs[<span class="hljs-number">16</span>] | <span class="hljs-number">0x20</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">// arm模式</span><br>    regs.uregs[<span class="hljs-number">16</span>] = regs.uregs[<span class="hljs-number">16</span>] &amp; <span class="hljs-number">0xFFFFFFDF</span>;<br>&#125;<br><span class="hljs-comment">// LR寄存器</span><br>regs.uregs[<span class="hljs-number">14</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>完成寄存器设置后，使用PTRACE_SETREGS将设置进程寄存器为修改后的寄存器，使用PTRACE_CONT恢复进程运行，waitpid等待进程触发返回异常,当进程触发返回异常断下是，waitpid返回状态码为<code>0xb7f</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ptrace_setregs(pid, &amp;regs) != <span class="hljs-number">0</span> || ptrace_continue(pid) != <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;call proc 0x%lx failed\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)proc_addr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">// 等待函数执行完返回错误</span><br>waitpid(pid, &amp;status, WUNTRACED);<br><span class="hljs-comment">// printf(&quot;0x%x\n&quot;, status);</span><br><span class="hljs-keyword">while</span> (status != <span class="hljs-number">0xb7f</span>)<br>&#123;<br>    ptrace_continue(pid);<br>    waitpid(pid, &amp;status, WUNTRACED);<br>&#125;<br></code></pre></td></tr></table></figure><p>进程返回后，使用PTRACE_GETREGS获取寄存器，读取返回值R0寄存器，并使用调用函数前保存的寄存器恢复进程寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">ptrace_getregs(pid, &amp;regs);<br><span class="hljs-comment">// 返回值在R0中</span><br>ret = (<span class="hljs-type">void</span> *)regs.uregs[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 恢复寄存器</span><br>ptrace_setregs(pid, &amp;saved_regs);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;proc 0x%lx return value: 0x%lx\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)proc_addr, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ret);<br><span class="hljs-keyword">return</span> ret;<br></code></pre></td></tr></table></figure><p>调用<code>malloc</code>函数和<code>dlopen</code>函数之前，需要获取函数在内存中的加载地址，读取<code>/proc/self/maps</code>文件可以得到<code>libc.so</code>和<code>libdl.so</code>加载的基地址，使用<code>dlopen</code>加载so文件，使用<code>dlsym</code>可以获得<code>malloc</code>和<code>dlopen</code>函数在注入器进程中的加载地址，与so文件基地址相减得到偏移地址，然后读取<code>/proc/pid/maps</code>文件可以获取待注入进程中<code>libc.so</code>和<code>libdl.so</code>加载基地址，根据偏移地址得到<code>malloc</code>和<code>dlopen</code>在待注入进程中的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取proc函数的内存地址</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">get_remote_proc_addr</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *lib_path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *proc_name)</span><br>&#123;<br>    <span class="hljs-type">void</span> *handle;<br>    <span class="hljs-type">void</span> *local_module_base;<br>    <span class="hljs-type">void</span> *local_proc_addr;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> proc_offset;<br>    <span class="hljs-type">void</span> *remote_module_base;<br>    <span class="hljs-type">void</span> *remote_proc_addr;<br>    <span class="hljs-comment">// 在本地加载lib文件并获取proc函数偏移</span><br>    handle = dlopen(lib_path, RTLD_LAZY);<br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open %s failed\n&quot;</span>, lib_path);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    dlerror();<br>    local_module_base = get_module_base(<span class="hljs-number">0</span>, lib_path);<br>    local_proc_addr = dlsym(handle, proc_name);<br>    proc_offset = local_proc_addr - local_module_base;<br>    dlclose(handle);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s offset: 0x%lx\n&quot;</span>, proc_name, proc_offset);<br>    remote_module_base = get_module_base(pid, lib_path);<br>    remote_proc_addr = remote_module_base + proc_offset;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s address: 0x%lx\n&quot;</span>, proc_name, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)remote_proc_addr);<br>    <span class="hljs-keyword">return</span> remote_proc_addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>注入器函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 注入so到进程</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inject_lib</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *lib_path)</span><br>&#123;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">void</span> *params[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">void</span> *proc_malloc;<br>    <span class="hljs-type">void</span> *proc_dlopen;<br>    <span class="hljs-type">void</span> *proc_dlerror;<br>    <span class="hljs-type">void</span> *mem_buf;<br>    proc_malloc = get_remote_proc_addr(pid, libc_path, <span class="hljs-string">&quot;malloc&quot;</span>);<br>    proc_dlopen = get_remote_proc_addr(pid, libdl_path, <span class="hljs-string">&quot;dlopen&quot;</span>);<br>    proc_dlerror = get_remote_proc_addr(pid, libdl_path, <span class="hljs-string">&quot;dlerror&quot;</span>);<br>    <span class="hljs-comment">// 首先附加到进程</span><br>    ptrace_attach(pid);<br>    <span class="hljs-comment">// 调用malloc分配内存写入lib文件路径</span><br>    params[<span class="hljs-number">0</span>] = (<span class="hljs-type">void</span> *)<span class="hljs-number">0x100</span>;<br>    mem_buf = ptrace_call(pid, proc_malloc, <span class="hljs-number">1</span>, params);<br>    <span class="hljs-keyword">if</span> (mem_buf == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc memory failed\n&quot;</span>);<br>        ptrace_continue(pid);<br>        ptrace_detach(pid);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc memory at 0x%lx\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)mem_buf);<br>    <span class="hljs-comment">// 将lib路径写入进程内存</span><br>    ptrace_write(pid, mem_buf, <span class="hljs-built_in">strlen</span>(lib_path) + <span class="hljs-number">1</span>, (<span class="hljs-type">void</span> *)lib_path);<br>    <span class="hljs-comment">// 调用dlopen将lib文件加载到进程</span><br>    params[<span class="hljs-number">0</span>] = mem_buf;<br>    params[<span class="hljs-number">1</span>] = (<span class="hljs-type">void</span> *)RTLD_LAZY;<br>    <span class="hljs-keyword">if</span> (ptrace_call(pid, proc_dlopen, <span class="hljs-number">2</span>, params) == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dlopen load %s to process %d failed\n&quot;</span>, lib_path, pid);<br>        <span class="hljs-comment">// 调用dlerror查看错误原因</span><br>        <span class="hljs-type">void</span> *err_addr = ptrace_call(pid, proc_dlerror, <span class="hljs-number">0</span>, params);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> err[<span class="hljs-number">0x100</span>];<br>        ptrace_read(pid, err_addr, <span class="hljs-number">0x100</span>, (<span class="hljs-type">void</span> *)err);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, err);<br>        ptrace_continue(pid);<br>        ptrace_detach(pid);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dlopen load %s to process %d succeed\n&quot;</span>, lib_path, pid);<br>    ptrace_continue(pid);<br>    ptrace_detach(pid);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译注入器上传到手机进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">❯ armv7a-linux-androideabi33-clang -o injector ptrace_injector.c<br>❯ adb push injector /data/local/tmp<br>injector: 1 file pushed, 0 skipped. 130.1 MB/s (11088 bytes in 0.000s)<br><br>❯ adb shell<br>lmipro:/ $ su<br>lmipro:/ # cd /data/local/tmp<br>lmipro:/data/local/tmp # ./injector com.example.crackme1 /data/local/tmp/libhook.so<br>pid of com.example.crackme1: 21551<br>/apex/com.android.runtime/lib/bionic/libc.so at 0xf6a52000<br>malloc offset: 0x2d685<br>/apex/com.android.runtime/lib/bionic/libc.so at 0xeac4f000<br>malloc address: 0xeac7c685<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xf6a0c000<br>dlopen offset: 0x1849<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xe9f92000<br>dlopen address: 0xe9f93849<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xf6a0c000<br>dlerror offset: 0x1853<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xe9f92000<br>dlerror address: 0xe9f93853<br>attach to process pid: 21551<br>proc 0xeac7c685 param 0 value: 0x100<br>proc 0xeac7c685 return value: 0x7b4e0700<br>malloc memory at 0x7b4e0700<br>write 0x1b bytes, start-addr: 0x7b4e0700<br>proc 0xe9f93849 param 0 value: 0x7b4e0700<br>proc 0xe9f93849 param 1 value: 0x1<br>proc 0xe9f93849 return value: 0x0<br>dlopen load /data/local/tmp/libhook.so to process 21551 failed<br>proc 0xe9f93853 return value: 0xec8f6514<br>read 0x100 bytes, start-addr: 0xec8f6514<br>dlopen failed: couldn&#x27;t map &quot;/data/local/tmp/libhook.so&quot; segment 2: Permission denied<br></code></pre></td></tr></table></figure><p>根据打印信息，注入器在待注入进程中调用<code>malloc</code>方法成功分配了内存，但是调用<code>dlopen</code>返回值为<code>NULL</code>，加载so文件失败，调用<code>dlerror</code>查看到返回错误消息为<code>dlopen failed: couldn&#39;t map &quot;/data/local/tmp/libhook.so&quot; segment 2: Permission denied</code>，说明so路径写入正确，进一步尝试发现，该错误与SELinux有关，开启SELinux模式后，进程无法加载非系统lib目录下的so文件，关闭SELinux后进行注入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">lmipro:/data/local/tmp # getenforce                                                                                                                       <br>Enforcing<br>lmipro:/data/local/tmp # setenforce 0                                                                                                                     <br>lmipro:/data/local/tmp # getenforce                                                                                                                       <br>Permissive<br>lmipro:/data/local/tmp # ./injector com.example.crackme1 /data/local/tmp/libhook.so                                                                       <br>pid of com.example.crackme1: 21551<br>/apex/com.android.runtime/lib/bionic/libc.so at 0xf274d000<br>malloc offset: 0x2d685<br>/apex/com.android.runtime/lib/bionic/libc.so at 0xeac4f000<br>malloc address: 0xeac7c685<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xf270c000<br>dlopen offset: 0x1849<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xe9f92000<br>dlopen address: 0xe9f93849<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xf270c000<br>dlerror offset: 0x1853<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xe9f92000<br>dlerror address: 0xe9f93853<br>attach to process pid: 21551<br>proc 0xeac7c685 param 0 value: 0x100<br>proc 0xeac7c685 return value: 0x7b4e0800<br>malloc memory at 0x7b4e0800<br>write 0x1b bytes, start-addr: 0x7b4e0800<br>proc 0xe9f93849 param 0 value: 0x7b4e0800<br>proc 0xe9f93849 param 1 value: 0x1<br>proc 0xe9f93849 return value: 0x5fe6de0b<br>dlopen load /data/local/tmp/libhook.so to process 21551 succeed<br></code></pre></td></tr></table></figure><p>注入成功，查看<code>/proc/pid/maps</code>中模块加载信息</p><p><img src="2023-10-09-13-32-08-image.png"></p><p>libhook.so成功加载到进程内存</p><h3 id="4-inline-hook"><a href="#4-inline-hook" class="headerlink" title="4.inline hook"></a>4.inline hook</h3><p>根据提示，选择hook的函数为<code>proc</code>，偏移地址<code>0x1134</code>，此处选择使用inline hook的方式实现</p><p>首先在<code>libhook.c</code>文件中定义替代<code>proc</code>的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">hookProc</span><span class="hljs-params">()</span><br>&#123;<br>    LOGD(<span class="hljs-string">&quot;hook and return TRUE&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数打印log信息并返回1，使<code>stringFromJNI</code>函数返回<code>right</code></p><p>跳转到该函数使用如下汇编指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm6502">LDR R0, [PC+8]<br>MOV PC, R0<br>hookProc_addr<br></code></pre></td></tr></table></figure><p>跳转码共12个字节，将<code>hookProc</code>的地址先加载到R0寄存器，使用MOV指令修改PC寄存器到<code>hookProc</code>函数，由于<code>hookProc</code>函数的作用是代替<code>proc</code>执行，参数、返回值、返回地址均不需要额外处理</p><p>修改<code>libcrackme1.so</code>加载处内存的保护权限，将12个字节跳转码写入<code>proc</code>函数起始处，完成hook操作</p><p>so文件注入后的自动执行可以使用<code>__attribute__((constructor))</code>属性声明函数，该属性声明的函数会在dlopen函数返回前执行</p><p>设置hook的代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sethook</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 首先获取libcrackme1.so加载的基地址</span><br>    <span class="hljs-type">void</span> *lib_base = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> proc_offset = <span class="hljs-number">0x1134</span>;<br>    <span class="hljs-type">void</span> *proc_addr;<br>    FILE *fp;<br>    <span class="hljs-type">char</span> line[<span class="hljs-number">0x100</span>];<br>    fp = fopen(<span class="hljs-string">&quot;/proc/self/maps&quot;</span>, <span class="hljs-string">&quot;rt&quot;</span>);<br>    fgets(line, <span class="hljs-number">0x100</span>, fp);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">strlen</span>(line) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(line, <span class="hljs-string">&quot;libcrackme1.so&quot;</span>) != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">sscanf</span>(line, <span class="hljs-string">&quot;%lx&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*)&amp;lib_base);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        fgets(line, <span class="hljs-number">0x100</span>, fp);<br>    &#125;<br>    fclose(fp);<br>    <span class="hljs-keyword">if</span> (lib_base == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        LOGD(<span class="hljs-string">&quot;get libcrackme1.so base failed&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    LOGD(<span class="hljs-string">&quot;libcrackme1.so at 0x%lx&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)lib_base);<br>    proc_addr = (<span class="hljs-type">void</span> *)((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)lib_base + proc_offset);<br>    LOGD(<span class="hljs-string">&quot;hook proc at 0x%lx&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)proc_addr);<br>    LOGD(<span class="hljs-string">&quot;new proc at 0x%lx&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)hookProc);<br>    <span class="hljs-comment">// LDR R0, [PC+8]</span><br>    <span class="hljs-comment">// MOV PC, R0</span><br>    <span class="hljs-comment">// hookProc</span><br>    <span class="hljs-comment">// 修改段保护</span><br>    <span class="hljs-keyword">if</span> (mprotect(lib_base, <span class="hljs-number">0x2000</span>, PROT_READ | PROT_WRITE | PROT_EXEC) != <span class="hljs-number">0</span>)<br>    &#123;<br>        LOGD(<span class="hljs-string">&quot;mprotect failed&quot;</span>);<br>        perror(<span class="hljs-string">&quot;mprotect&quot;</span>);<br>        LOGD(<span class="hljs-string">&quot;Error: %s\n&quot;</span>, strerror(errno));<br>    &#125;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> jumpCode[<span class="hljs-number">0xc</span>] = &#123;<span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x9F</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0xE1</span>&#125;;<br>    *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)(jumpCode + <span class="hljs-number">8</span>) = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)hookProc;<br>    __memcpy(proc_addr, (<span class="hljs-type">void</span> *)jumpCode, <span class="hljs-number">0xc</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>设置log和so入口函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">onload</span><span class="hljs-params">()</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((constructor))</span>;<br><br><span class="hljs-type">void</span> (*__android_log_print)(<span class="hljs-type">int</span> i, ...);<br><span class="hljs-type">void</span> *handle;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TAG <span class="hljs-string">&quot;Crack&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOGD(...) __android_log_print(3, TAG, __VA_ARGS__)  </span><br><span class="hljs-type">void</span> *(*__memcpy)(<span class="hljs-type">void</span> *dst, <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> n);<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">onload</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 设置LOGD</span><br>    handle = dlopen(<span class="hljs-string">&quot;/system/lib/liblog.so&quot;</span>, RTLD_LAZY);<br>    __android_log_print = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">int</span>, ...))dlsym(handle, <span class="hljs-string">&quot;__android_log_print&quot;</span>);<br>    dlclose(handle);<br>    <span class="hljs-comment">// 获取memcpy</span><br>    handle = dlopen(<span class="hljs-string">&quot;/apex/com.android.runtime/lib/bionic/libc.so&quot;</span>, RTLD_LAZY);<br>    __memcpy = (<span class="hljs-type">void</span> *(*)(<span class="hljs-type">void</span> *, <span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span>))dlsym(handle, <span class="hljs-string">&quot;memcpy&quot;</span>);<br>    dlclose(handle);<br><br>    LOGD(<span class="hljs-string">&quot;injected by noxke&quot;</span>);<br>    sethook();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的<code>__android_log_print</code>和<code>memcpy</code>需要使用<code>dlopen</code>和<code>dlsym</code>获取</p><p>编译hook代码，上传并注入到<code>com.example.crackme1</code>进程中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">armv7a-linux-androideabi33-clang libhook.c -shared -fPIC -o libhook.so<br>❯ adb push libhook.so /data/local/tmp/<br>libhook.so: 1 file pushed, 0 skipped. 106.0 MB/s (7180 bytes in 0.000s)<br><br>❯ adb shell<br>lmipro:/ $ cd /data/local/tmp<br>lmipro:/data/local/tmp $ su<br>lmipro:/data/local/tmp # ./injector com.example.crackme1 /data/local/tmp/libhook.so<br></code></pre></td></tr></table></figure><p>使用logcat查看log信息</p><p><img src="2023-10-09-13-46-53-image.png"></p><p>随意输入字符串，点击确定按钮</p><img src="2023-10-09-13-47-45-image.png" title="" alt="" width="216"><p>logcat打印日志</p><p><img src="2023-10-09-13-48-34-image.png"></p><p>hook结果与所需结果相同，<code>proc</code>代码的调用会被跳转到<code>hookProc</code>执行并返回，<code>stringFromJNI</code>返回<code>right</code>字符串</p><p>使用ida查看修改后的<code>proc</code>函数和<code>hookProc</code>函数</p><img src="2023-10-09-13-51-27-image.png" title="" alt="" width="492"><img src="2023-10-09-13-52-02-image.png" title="" alt="" width="489">]]></content>
    
    
    <categories>
      
      <category>腾讯游戏客户端安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动端调试环境搭建</title>
    <link href="/2023/10/02/TencentGameClient/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/10/02/TencentGameClient/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>本篇将介绍安卓软件Java层和Native层调试工具的安装和简单使用</p><p>涉及到的软件如下</p><p><a href="https://developer.android.google.cn/studio?hl=zh-cn">Android studio</a></p><p><a href="https://github.com/skylot/jadx">jadx</a></p><p><a href="https://hex-rays.com/IDA-pro/">Ida Pro</a></p><h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><blockquote><p>jadx和Ida的安装使用都很简单，此处不做介绍，安装Android studio过程需要确保有正常的网络环境，网络配置不做介绍</p></blockquote><ol><li><p>插件安装</p><p><a href="https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack----/versions#tabs">Chinese (Simplified) Language Pack &#x2F; 中文语言包 - IntelliJ IDEs Plugin | Marketplace</a></p><p><a href="https://github.com/JesusFreke/smalidea">GitHub - JesusFreke&#x2F;smalidea: smalidea is a smali language plugin for IntelliJ IDEA</a></p></li><li><p>SDK安装</p><p>打开SDK Manager，修改sdk目录，安装如下SDK工具</p><p><img src="2023-10-06-01-08-30-image.png"></p></li><li><p>添加环境变量</p><p>将<code>$sdkPath/platform-tools/</code></p><p><code>$sdkPath//opt/android-studio-sdk/ndk/26.0.10792818/toolchains/llvm/prebuilt/linux-x86_64/bin/</code>添加到环境变量，ndk变量需要根据自己的环境情况进行添加</p></li><li><p>创建Android Virtual Device(AVD)虚拟机</p><p>打开Virtual Device Manager</p><p>选择创建，按照个人习惯，机型选择<code>Pixel XL</code>，镜像选择<code>Oreo</code>(API27 x86 Android 8.1)，如果是64位环境，选择<code>Tiramisu</code>(API33 x86_64 Android 13.0)</p></li></ol><p>   将Device Frame的勾取消，点击完成即可创建</p><h4 id="Android-Studio调试"><a href="#Android-Studio调试" class="headerlink" title="Android Studio调试"></a>Android Studio调试</h4><p>选择右图<code>Profile or Debug APK</code></p><p><img src="2023-10-06-01-20-26-image.png"></p><p>有可能打开后和左图一样，没有<code>Profile or Debug APK</code>选项，如果出现该情况，进入到插件设置，启用Android APK Support和Android NDK Support并重启Android Studio</p><img src="2023-10-06-01-22-03-image.png" title="" alt="" width="573"><p>选择<code>Profile or Debug APK</code>后，选中需要调试的apk文件</p><p><img src="2023-10-06-01-25-31-image.png"></p><p>左侧选择java并找到要调试的类，打开编译后的smali代码，对smali代码不了解的可以使用jadx工具对照查看反编译的java代码</p><p><img src="2023-10-06-01-28-14-image.png"></p><blockquote><p>虽然jadx也可以进行动态调试，但不推荐，很多情况下无法看到寄存器的值</p></blockquote><p>选择调试的AVD虚拟机并编辑调试配置文件</p><p><img src="2023-10-06-01-29-30-image.png"></p><p>将Debuger类型修改为Java Only，不修改的情况下会默认附加lldb调试器，导致ida调试器无法附加</p><img src="2023-10-06-01-30-49-image.png" title="" alt="" width="523"><p>在Device Manager中启动AVD虚拟机</p><p><img src="2023-10-06-01-33-43-image.png"></p><p>下断点并点击调试</p><p><img src="2023-10-06-01-34-24-image.png"></p><p><img src="2023-10-06-01-35-02-image.png"></p><p>正常情况下程序会断下并进入调试状态，但有时会出现无法调试的情况，如果发生该情况，到插件管理禁用Android APK Support和Android NDK Support(可不进行重启)</p><p>剩下的调试部分不做介绍</p><h4 id="Ida调试"><a href="#Ida调试" class="headerlink" title="Ida调试"></a>Ida调试</h4><p>确保上述操作AVD虚拟机启动和软件进入调试状态</p><p>提取程序的lib文件(使用unzip解压apk文件，在lib目录中找到对于处理器架构的so文件)</p><p>将Ida的dbgsrv目录下的对应架构的调试服务器上传到AVD虚拟机中，例如本题为<code>android_x86_server</code>，开启29346端口转发(开启转发失败时去掉-s选项)</p><p><img src="2023-10-06-01-50-32-image.png"></p><p>adb shell进入到AVD虚拟机的命令行，su切换到root权限，进入dbgsrv目录</p><p><img src="2023-10-06-01-43-05-image.png"></p><p>为<code>android_x86_server</code>添加可执行权限并运行</p><p><img src="2023-10-06-01-44-19-image.png"></p><p>启动ida32并选择要调试的so文件(不建议修改文件名)</p><p>找到需要调试的函数下断点</p><p>选择调试器为<code>Remote Linux debugger</code></p><p><img src="2023-10-06-01-47-07-image.png"></p><p>Debugger-&gt;Process Option设置Hostname为<code>127.0.0.1</code></p><img src="2023-10-06-01-49-22-image.png" title="" alt="" width="500"><p>Debugger-&gt;Attach to process选择要调试的进程</p><img src="2023-10-06-01-55-00-image.png" title="" alt="" width="500"><p>出现询问模块名相同选择<code>Same</code></p><img src="2023-10-06-01-55-55-image.png" title="" alt="" width="507"><p>Ida附加后会自动断下，按F9运行一次</p><p>回到Android Studio单步执行native函数，Ida会在断点处断下</p><p>剩下的调试部分不做介绍</p>]]></content>
    
    
    <categories>
      
      <category>腾讯游戏客户端安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游戏客户端开发基础-移动篇(视频习题)</title>
    <link href="/2023/10/02/TencentGameClient/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-%E7%A7%BB%E5%8A%A8%E7%AF%87(%E8%A7%86%E9%A2%91%E4%B9%A0%E9%A2%98)/"/>
    <url>/2023/10/02/TencentGameClient/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-%E7%A7%BB%E5%8A%A8%E7%AF%87(%E8%A7%86%E9%A2%91%E4%B9%A0%E9%A2%98)/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/noxke/TencentGameClientOpenCourse">GitHub - noxke&#x2F;TencentGameClientOpenCourse: 腾讯游戏客户端公开课2023 腾讯菁英班</a></p><h3 id="1-静态分析"><a href="#1-静态分析" class="headerlink" title="1.静态分析"></a>1.静态分析</h3><h4 id="Java层"><a href="#Java层" class="headerlink" title="Java层"></a>Java层</h4><p>使用jadx打开题目<code>gslab.demo.apk</code>文件，查看<code>AndroidManifest.xml</code>文件获取软件入口activity为<code>com.example.x86demo.MainActivity</code></p><p>查看该入口activity类的<code>onCreate</code>方法</p><p><img src="2023-10-05-22-42-18-image.png"></p><p>TextView对象<code>tv</code>设置的字符串来自<code>stringFromJNI</code>方法</p><p><img src="2023-10-05-22-43-55-image.png"></p><p>查看其余部分，<code>stringFromJNI</code>是<code>native-lib</code>中的native函数</p><h4 id="Native层"><a href="#Native层" class="headerlink" title="Native层"></a>Native层</h4><p>该软件提供了<code>armabi-v7a</code>和<code>x86</code>两种处理器架构的<code>libnative-lib.so</code>文件，此处对arm架构so文件进行分析</p><p>使用readelf命令查看<code>libnative-lib.so</code>的导出函数</p><img src="2023-10-05-22-50-46-image.png" title="" alt="" width="527"><p><code>stringFromJNI</code>导出函数的偏移地址为<code>0x08bdd</code>，完整导出名称为<code>Java_com_example_x86demo_MainActivity   _stringFromJNI</code></p><blockquote><p>arm指令集每条指令长度为32位，存在指令对其，指令地址低两位均为0，而此处偏移地址最低位为1，表示处理器执行到该处时进入Thumb模式，指令长度变为16位或32位，实际指令偏移地址为<code>0x8bdc</code></p></blockquote><p>使用ida32打开<code>libnative-lib.so</code>文件，定位到导出函数，指令长度大多为16位，表示处理器执行该函数时处于Thumb模式</p><p>反编译查看该函数</p><img src="2023-10-05-22-58-44-image.png" title="" alt="" width="527"><p>程序使用C++的string类构造string对象并返回，注意到除了<code>sub_E36E2CA6</code>函数外其它函数均为库函数，因此选择该函数进行hook</p><h3 id="2-动态调试"><a href="#2-动态调试" class="headerlink" title="2.动态调试"></a>2.动态调试</h3><blockquote><p>使用真机(android 13)进行调试，调试工具为android studio和ida</p></blockquote><h4 id="Java层-1"><a href="#Java层-1" class="headerlink" title="Java层"></a>Java层</h4><p>对<code>stringFromJNI</code>调用处的smali代码下断点，连接设备进行调试</p><img src="2023-10-05-23-06-29-image.png" title="" alt="" width="533"><p>程序在断点处断下，单步跳过查看<code>stringFromJNI</code>函数的返回值(v1寄存器)</p><img title="" src="2023-10-05-23-08-51-image.png" alt="" width="533"><p>函数返回结果为字符串对象<code>Hello from C++</code></p><p>继续运行程序，屏幕显示<code>Hello from C++</code>字符串</p><h4 id="Native层-1"><a href="#Native层-1" class="headerlink" title="Native层"></a>Native层</h4><p>开启adb端口转发，将ida的dbgsrv上传到手机，进入shell切换到root权限启动dbgsrv</p><p><img src="2023-10-05-23-17-30-image.png"></p><p>android studio上开启调试，程序在smali代码断下</p><p>ida对<code>stringFromJNI</code>函数下断点，连接调试器并附加到<code>com.example.x86demo</code>进程，按F9继续运行</p><img src="2023-10-05-23-18-48-image.png" title="" alt="" width="532"><p>android studio单步执行，ida上程序在<code>stringFromJNI</code>函数断下</p><img src="2023-10-05-23-20-56-image.png" title="" alt="" width="507"><blockquote><p>此处处理器处于Thumb模式</p></blockquote><p>断点到<code>sub_E3722CA6</code>函数内部</p><img src="2023-10-05-23-22-52-image.png" title="" alt="" width="505"><p>函数只做了参数传递并调用<code>sub_E3723258</code>函数，<code>sub_E3722CA6</code>的参数为<code>R0</code>寄存器，值为<code>0xFF98C0E8</code>，显然为一个地址，跳转到该地址处</p><img src="2023-10-05-23-26-11-image.png" title="" alt="" width="513"><p>猜测该位置为一个结构体，结构体第一个整数为0x11，第二个整数为0x0E，第三个整数为<code>0x77EB6850</code>，第三个数明显为地址，跳转到该地址处</p><img src="2023-10-05-23-28-16-image.png" title="" alt="" width="509"><p>该地址处为字符串<code>Hello from C++</code>，对该字符串进行修改测试</p><img src="2023-10-05-23-29-30-image.png" title="" alt="" width="511"><p>ida使用F9运行，android studio单步断下，查看<code>stringFromJNI</code>返回值</p><img src="2023-10-05-23-30-42-image.png" title="" alt="" width="509"><p>返回值变为了上面修改的字符串，继续运行程序，屏幕上显示修改后的字符串</p><img src="2023-10-05-23-32-24-image.png" title="" alt="" width="451"><h3 id="3-使用ptrace注入并hook程序"><a href="#3-使用ptrace注入并hook程序" class="headerlink" title="3.使用ptrace注入并hook程序"></a>3.使用ptrace注入并hook程序</h3><blockquote><p>上述分析中选择<code>sub_E36E2CA6</code>函数进行hook，该函数偏移为<code>0x8ca6</code>，后续称为<code>proc</code></p><p>该函数的调用关系为<code>onCreate-&gt;stringFromJNI-&gt;proc</code>，由于该函数在程序启动时执行，几乎没有等待时间，所以在正常执行的情况下不能够保证100%hook成功</p></blockquote><p>本题使用traphook的方式修改proc函数的参数，思路如下：</p><ol><li><p>ptrace在proc函数开始位置设置软件断点</p></li><li><p>waitpid捕获进程停止信息</p></li><li><p>ptrace获取proc函数参数R0寄存器，得到字符串地址</p></li><li><p>ptrace修改字符串地址处的字符串</p></li><li><p>ptrace禁用断点，恢复程序执行</p></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>ptrace函数需要待附加进程的pid，使用<code>pidof com.example.x86demo</code>命令可以获得软件的<code>pid</code></p><p>想要hook <code>proc</code>函数，需要知道其内存中的加载地址，在静态分析中得到了其偏移地址<code>proc_offset = 0x8ca6</code>，还需要<code>libnative-lib.so</code>文件加载的基地址才能计算出<code>proc</code>函数的地址，安卓进程加载的库文件信息可以在<code>/proc/pid/maps</code>文件中找到</p><img src="2023-10-06-00-03-12-image.png" title="" alt="" width="581"><p>如图，本次程序运行<code>libnative-lib.so</code>的加载地址为<code>lib_base = e381d000</code>，<code>proc</code>函数的地址为<code>proc_addr = lib_base + proc_offset</code></p><p>c语言中使用popen函数执行命令行目录并获取结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取进程pid和libnative-lib.so加载的基地址</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>    fp = popen(<span class="hljs-string">&quot;pidof com.example.x86demo &amp;&amp; cat /proc/`pidof com.example.x86demo`/maps | grep libnative-lib.so&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    fread(cli_output, <span class="hljs-number">1</span>, <span class="hljs-number">1024</span>, fp);<br>    pclose(fp);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(cli_output) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">sscanf</span>(cli_output, <span class="hljs-string">&quot;%d%lx&quot;</span>, &amp;demo_pid, &amp;lib_base);<br>        <span class="hljs-keyword">if</span> (lib_base == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;demo_pid: %d\n&quot;</span>, demo_pid);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;libnative-lib.so image base: 0x%lx\n&quot;</span>, lib_base);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="2023-10-06-00-06-29-image.png"></p><p>使用ptrace附加到进程并将<code>proc</code>函数第一条指令修改为软件断点，设置断点前需要保存原始指令，确保后续能够使程序正确运行，设置断点后恢复进程运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bp_code = <span class="hljs-number">0x0000BEFF</span>;  <span class="hljs-comment">// 设置FF号断点</span><br><span class="hljs-comment">// 需要hook的函数偏移</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> proc_offset = <span class="hljs-number">0x8ca6</span>;<br><span class="hljs-comment">// 需要hook的函数地址</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> proc_addr = lib_base + proc_offset;<br>    <span class="hljs-comment">// 附加到目标进程</span><br>ptrace(PTRACE_ATTACH, pid, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>waitpid(pid, &amp;status, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 先保存断点前的指令，再将其设置为断点代码</span><br>ori_code = ptrace(PTRACE_PEEKDATA, pid, (<span class="hljs-type">void</span> *)proc_addr, <span class="hljs-literal">NULL</span>);<br>ptrace(PTRACE_POKEDATA, pid, (<span class="hljs-type">void</span> *)proc_addr, (<span class="hljs-type">void</span> *)bp_code);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set breakpoint at 0x%lx\n&quot;</span>, proc_addr);<br>ptrace(PTRACE_CONT, pid, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>当处理器执行到软件断点时会发出<code>SIGTRAP</code>信号，使用waitpid捕获断点信号，并获取寄存器信息，判断PC寄存器地址是否为断点地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 捕获断点</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>    waitpid(pid, &amp;status, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (WIFSTOPPED(status) &amp;&amp; WSTOPSIG(status) == SIGTRAP)<br>    &#123;<br>        <span class="hljs-comment">// 获取寄存器信息</span><br>        ptrace(PTRACE_GETREGS, pid, <span class="hljs-literal">NULL</span>, &amp;regs);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pc = regs.uregs[<span class="hljs-number">15</span>];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;break at 0x%lx\n&quot;</span>, pc);<br>        <span class="hljs-keyword">if</span> (pc == proc_addr)<br>        &#123;<br>            <span class="hljs-comment">// hook操作</span><br>        &#125;<br>    &#125;<br>    ptrace(PTRACE_CONT, pid, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当程序在设置的断点处断下后，寄存器R0的值为proc函数的参数，其值为地址，<code>R0+8</code>为字符串地址，使用ptrace修改<code>R0+8</code>处的字符串，实现对<code>stringFromJNI</code>返回值的修改</p><p>完成修改后需要将断点恢复为原始指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取R0寄存器</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r0 = regs.uregs[<span class="hljs-number">0</span>];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> str_addr = ptrace(PTRACE_PEEKDATA, pid, (<span class="hljs-type">void</span> *)(r0 + <span class="hljs-number">8</span>), <span class="hljs-literal">NULL</span>);<br><span class="hljs-type">char</span> ori_str[<span class="hljs-number">0x20</span>];<br><span class="hljs-type">char</span> new_str[<span class="hljs-number">0x20</span>];<br><span class="hljs-built_in">strcpy</span>(new_str, hack_str);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x20</span>; i += <span class="hljs-number">4</span>)<br>&#123;<br>    *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)(ori_str + i) = ptrace(PTRACE_PEEKDATA, pid, (<span class="hljs-type">void</span> *)(str_addr + i), <span class="hljs-literal">NULL</span>);<br>    ptrace(PTRACE_POKEDATA, pid, (<span class="hljs-type">void</span> *)(str_addr + i), (<span class="hljs-type">void</span> *)(*(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)(new_str + i)));<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str at 0x%lx\n&quot;</span>, str_addr);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ori str: %s\n&quot;</span>, ori_str);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new str: %s\n&quot;</span>, new_str);<br><span class="hljs-comment">// 恢复原来的指令</span><br>ptrace(PTRACE_POKEDATA, pid, (<span class="hljs-type">void</span> *)proc_addr, (<span class="hljs-type">void</span> *)ori_code);<br></code></pre></td></tr></table></figure><p>编译程序并上传到手机测试</p><p><img src="2023-10-06-00-21-03-image.png"></p><img src="2023-10-06-00-22-22-image.png" title="" alt="" width="296"><blockquote><p>x86的hook实现与arm的实现基本相同，除了<code>proc</code>函数的偏移地址不同，以及断点指令不同以外，还需要注意x86处理器在执行int3断点后会将EIP+1，捕获断点后除了将断点指令恢复，还需要将EIP寄存器恢复</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>腾讯游戏客户端安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游戏客户端开发基础-PC篇</title>
    <link href="/2023/09/26/TencentGameClient/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-PC%E7%AF%87/"/>
    <url>/2023/09/26/TencentGameClient/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-PC%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/noxke/TencentGameClientOpenCourse">GitHub - noxke&#x2F;TencentGameClientOpenCourse: 腾讯游戏客户端公开课2023 腾讯菁英班</a></p><h3 id="1-程序分析"><a href="#1-程序分析" class="headerlink" title="1.程序分析"></a>1.程序分析</h3><p>使用ida打开crackme.exe，进入到程序的主逻辑函数，注意到有大量的xmm寄存器，但是不含call指令，先忽略，注意到两个特殊部分：</p><p><img src="pic2.png"></p><p>左图中调用了CreateThread函数创建子线程运行StartAddress处函数，右侧含有分支判断，完成判断后sleep并返回，猜测该处与程序的判断逻辑有关</p><p>F5查看反编译代码</p><img src="pic3.png" title="" alt="" width="396"><p>末尾进行了数据串的比较，后根据比较结果为v32地址处的4个字节赋值，紧接着两个字节赋值<code>0x0a,0x0d</code>，换行回车符号，猜测v32地址处为输出字符串，结合测试时的输出<code>错误</code>，猜测<code>0xCBF9DBB4 0x8FFFCBD5</code>经过异或后为gbk编码格式的字符串，在线编码工具测试，猜测成立</p><img src="pic4.png" title="" alt="" width="485"><p>显然，v37处储存的内容影响最后的输出结果，对<code>v32=v37</code>下断点启动调试，随意输入字符串后在该处断下，查看v32内容</p><p><img src="pic5.png"></p><p>显然, v37为输入的原内容，根据比较部分可以得知，<code>v37-48</code>处为flag</p><p><img src="pic6.png"></p><p>得到程序flag<code>HiGWDUuXQS6wVHBTp0ERfJe6VqprMqD1</code></p><img src="pic7.png" title="" alt="" width="404"><p>分析剩余部分得到程序的输入函数和输出函数，后续将称其为<code>printf scanf</code></p><p><img src="pic8.png"></p><h3 id="2-DLL注入分析"><a href="#2-DLL注入分析" class="headerlink" title="2.DLL注入分析"></a>2.DLL注入分析</h3><p>题目要求使用<code>CreateRemoteThread</code>api进行注入</p><blockquote><p>最基础的代码注入方式, 使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread"><code>CreateRemoteThread</code></a>在目标进程下创建远程线程, 调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya"><code>LoadLibraryA</code></a>加载DLL到目标进程, DLL加载&#x2F;卸载时调用<code>DllMain</code>函数, 执行注入DLL中的代码, <code>LoadLibraryA</code>参数需要先写入目标进程的内存, 使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex"><code>VirtualAllocEx</code></a>在目标进程内存下分配内存, 使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory"><code>WriteProcessMemory</code></a>将需要注入的DLL地址写入目标内</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID);<br>pRemoteBuf = VirtualAllocEx(hProcess, <span class="hljs-literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);<br>WriteProcessMemory(hProcess, pRemoteBuf, dllPath, dwBufSize, <span class="hljs-literal">NULL</span>);<br>hMod = GetModuleHandleA((LPCSTR)<span class="hljs-string">&quot;kernel32.dll&quot;</span>);<br>pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="hljs-string">&quot;LoadLibraryA&quot;</span>);<br>CreateRemoteThread(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, pThreadProc, pRemoteBuf, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><blockquote><p>创建远程线程时传入的<code>LoadLibraryA</code>地址并不是直接获取目标进程中的函数地址, 因为系统DLL在不同进程中加载地址相同</p></blockquote><p>编写一个输出字符串的DLL进行注入测试<br><img title="" src="pic9.png" alt="" width="359"></p><p><img src="pic10.png"></p><p>注入creackme.exe失败，但注入其他程序正常，重新分析代码，分析<code>CreateThread</code>函数创建的线程执行的<code>StartAddress</code>处代码，找到关键位置</p><p><img src="pic11.png"></p><p>此处将<code>LoadLibraryExW</code>函数的内存权限修改为可写入，然后将第一个字节patch成-61（0xC3, ret指令），将指令第一行修改为ret指令，将<code>LoadLibraryExW</code>函数patch掉了，因此<code>LoadLibraryA</code>函数也无法正常使用</p><p><img src="pic12.png"></p><p>不过中间有10秒的sleep,在启动后就注入即可</p><p><img src="pic13.png"></p><h3 id="3-hook代码"><a href="#3-hook代码" class="headerlink" title="3.hook代码"></a>3.hook代码</h3><p>将输出结果修改称正确，patch一下分支语句或者将错误的gbk编码patch成正确就可以，但是题目要求用DLL注入hook程序，因此此处用注入的DLL修改程序，hook掉<code>printf</code>函数，思路如下</p><blockquote><p>将<code>printf</code>前几行指令修改为跳转指令，跳转到注入的shellcode中，在shellcode中判断<code>printf</code>的参数（即待输出的字符串）是否为<code>错误</code>，如果为<code>错误</code>，将其修改为<code>正确</code>，替换完成后在shellcode中执行<code>printf</code>前几行被替换的指令，然后返回到<code>printf</code>函数继续执行，输出修改后的字符串</p></blockquote><p>printf修改前后代码:</p><img src="pic14.png" title="" alt="" width="528"><p>修改前前4条指令为将寄存器参数压入堆栈，此处将其修改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nasm">mov eax, $shellcode<br>push rax<br>ret<br></code></pre></td></tr></table></figure><p>将shellcode的地址压入堆栈中，使用ret指令跳转到shellcode代码出，shellcode代码如下（前后填充的nop省略）</p><img src="pic15.png" title="" alt="" width="521"><p>主要代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nasm">mov eax, [rcx]         ; 将printf第一个参数(输出字符串)的前四个字节传送到eax<br>cmp eax, 0xF3CEEDB4    ; 判断这四个字节是否为错误两个字的gbk编码<br>jne $+0x8              ; 不是错误两个字的gbk编码则跳过接下来两条指令<br>mov eax, 0xB7C8FDD5    ; 如果是错误两个字的gbk编码，将其修改为正确两个字的gbk编码<br>mov [rcx], eax         ; 将这四个字节写回输出字符串，完成替换<br>;原printf函数前4条指令    ; 为printf完成参数压栈<br>mov rax, $printf+0x20  ; printf的指令位置，跳过修改的代码<br>push rax               ; push ret压栈返回<br>ret<br></code></pre></td></tr></table></figure><p>只需要在注入的DLL中计算printf的地址，将地址写入shellcode,将shellcode写入可执行内存，再hook掉printf的代码即可完成修改操作</p><p>设置hook代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">set_hook</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// hook printf函数</span><br>    DWORD64 pProc;<br>    DWORD64 pProcOffset = <span class="hljs-number">0x1020</span>;<br>    HMODULE hModule = GetModuleHandle(nullptr);<br>    DWORD_PTR baseAddress = reinterpret_cast&lt;DWORD_PTR&gt;(hModule);<br>    pProc = (DWORD64)baseAddress + pProcOffset;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nhook proc addr : 0x%llx\n&quot;</span>, pProc);<br>    <span class="hljs-comment">// 修改shellcode中的返回地址 printf+0x10</span><br>    *((DWORD64 *)((<span class="hljs-type">uint8_t</span> *)shellcode + <span class="hljs-number">0x50</span> - <span class="hljs-number">0x1A</span>)) = (pProc + <span class="hljs-number">0x10</span>);<br>    <span class="hljs-comment">// 写入shellcode</span><br>    LPVOID shellcodeBuf = VirtualAlloc(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x50</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(shellcodeBuf, shellcode, <span class="hljs-number">0x50</span>);<br>    DWORD64 dwShellcodeBuf = (DWORD64)shellcodeBuf;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nshell code addr : 0x%llx\n&quot;</span>, dwShellcodeBuf);<br>    <span class="hljs-comment">// 修改函数内存保护权限</span><br>    VirtualProtect((LPVOID)pProc, <span class="hljs-number">20</span>, PAGE_EXECUTE_READWRITE, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 修改hookcode中的shellcode地址</span><br>    *((DWORD64 *)((<span class="hljs-type">uint8_t</span> *)hookcode + <span class="hljs-number">6</span>)) = dwShellcodeBuf;<br>    <span class="hljs-comment">// 获取进程句柄</span><br>    HANDLE hProcess = GetCurrentProcess();<br>    <span class="hljs-comment">// hook printf函数</span><br>    WriteProcessMemory(hProcess, (LPVOID)pProc, hookcode, <span class="hljs-number">20</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于PE文件加载时会进行重定向操作，所以printf函数的地址不固定，需要通过PE文件加载的基地址+函数偏移量得到printf函数的准确地址，另外shellcode需要申请可执行内存块确保指令可以正常执行，需要修改printf函数的内存块可写，修改其前几行指令</p><p>注入后运行程序，任意输入均返回正确</p>]]></content>
    
    
    <categories>
      
      <category>腾讯游戏客户端安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
