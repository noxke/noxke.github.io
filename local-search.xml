<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>UE4外挂实现分析-PC端</title>
    <link href="/2023/11/12/TencentGameClient/UE4%E5%A4%96%E6%8C%82%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90-PC%E7%AB%AF/"/>
    <url>/2023/11/12/TencentGameClient/UE4%E5%A4%96%E6%8C%82%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90-PC%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/noxke/TencentGameClientOpenCourse">GitHub - noxke&#x2F;TencentGameClientOpenCourse: 腾讯游戏客户端公开课2023 腾讯菁英班</a></p><h3 id="游戏分析"><a href="#游戏分析" class="headerlink" title="游戏分析"></a>游戏分析</h3><blockquote><p>分析工具：</p><p><a href="https://github.com/cheat-engine/cheat-engine">Cheat Engine 7.5</a></p><p><a href="https://github.com/x64dbg/x64dbg">x64dbg</a></p><p><a href="https://hex-rays.com/IDA-pro/">IDA Pro</a></p></blockquote><blockquote><p>参考文章：</p><p><a href="http://www.pentester.top/index.php/archives/117/">UE4逆向笔记之GWORLD GName GameInstance - 小透明‘s Blog</a></p></blockquote><p>本次分析的游戏使用UE4.22引擎开发，外挂实现功能有透视和自瞄，两项功能都基于游戏内玩家对象和敌人对象的坐标位置实现。UE4游戏内对象的结构如下图所示</p><p><img src="assets/2023-11-12-18-23-09-4234669859.png"></p><blockquote><p>图片中的对象偏移与UE引擎版本相关，存在误差。</p></blockquote><p>根据上图的关系，游戏中所有的对象都挂在<code>UWorld</code>下面，通过<code>UWorld-&gt;GameInstance-&gt;ULocalPlayer-&gt;LocalPlayer-&gt;PlayerController-&gt;Actor</code>可以获取到游戏玩家的Actor对象，进而获取玩家的坐标等信息</p><p>通过<code>PWorld-&gt;ULevel-&gt;ActorCount</code>和<code>PWorld-&gt;ULevel-&gt;ActorArray</code>可以遍历游戏中所有的Actor对象，包括敌人的Actor对象，进而获取敌人坐标信息，在一局游戏中，<code>PWorld</code>指针与<code>UWorld</code>相同</p><h4 id="CE分析UWorld"><a href="#CE分析UWorld" class="headerlink" title="CE分析UWorld"></a>CE分析UWorld</h4><p>开启游戏使用CE打开游戏进程</p><p>寻找游戏内能直接获取的与玩家信息有关的详细数据，游戏中子弹数量能够直接查看到准确数值，并且方便控制，因此使用CE查找子弹数量的地址</p><p>首先搜索准确的32位整数50</p><p><img src="assets/2023-11-12-18-45-27-image.png"></p><p>开枪减少子弹数量，继续搜索48</p><p><img src="assets/2023-11-12-18-46-13-image.png"></p><p>只剩两个地址，修改这两个地址处的值，查看游戏内子弹数量是否发生变化，</p><p><img src="assets/2023-11-12-18-48-17-image.png"></p><p>可以确定子弹数量储存在<code>0x1E3EDF40684</code>地址处，对该地址进行指针分析</p><p><img src="assets/2023-11-12-18-50-35-image.png"></p><p>根据<code>GameInstance</code>到<code>PlayerController</code>的偏移关系<code>0x38 -&gt; 0x0 -&gt; 0x30</code>过虑到如下指针链</p><p><img src="assets/2023-11-12-18-55-50-image.png"></p><p>其中存在条指针链</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;ShooterClient.exe&quot;</span>+<span class="hljs-number">02F</span>6E6E8-&gt;<span class="hljs-number">0xD80</span>-&gt;<span class="hljs-number">0x38</span>-&gt;<span class="hljs-number">0x0</span>-&gt;<span class="hljs-number">0x30</span>-&gt;<span class="hljs-number">0x3B0</span>-&gt;<span class="hljs-number">0x778</span>-&gt;<span class="hljs-number">0x584</span><br><span class="hljs-string">&quot;ShooterClient.exe&quot;</span>+<span class="hljs-number">02F</span>71060-&gt;<span class="hljs-number">0x160</span>-&gt;<span class="hljs-number">0x38</span>-&gt;<span class="hljs-number">0x0</span>-&gt;<span class="hljs-number">0x30</span>-&gt;<span class="hljs-number">0x3B0</span>-&gt;<span class="hljs-number">0x778</span>-&gt;<span class="hljs-number">0x584</span><br></code></pre></td></tr></table></figure><p>因此可以分析出<code>UWorld</code>为<code>ShooterClient.exe+02F6E6E8</code>或<code>ShooterClient.exe+02F71060</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">UWorld = [ShooterClient.exe+<span class="hljs-number">0x02F71060</span>]<br>GameInstance = [UWorld+<span class="hljs-number">0x160</span>]<br>ULocalPlayer = [GameInstance+<span class="hljs-number">0x38</span>]<br>LocalPlayer=[ULocalPlayer]<br>PlayerController = [LocalPlayer+<span class="hljs-number">0x30</span>]<br>PlayerActor = [PlayerController+<span class="hljs-number">03B</span>0]ReadProcessMemory(hProcess, (LPVOID)((BYTE*)baseAddr + <span class="hljs-number">0x2E6E0C0</span>), (LPVOID)&amp;GName, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>继续使用浮点数模糊搜索玩家坐标、视角信息等，由于已经确定玩家子弹数量地址，因此可以缩小搜索范围在<code>0x1E3EDF40684</code>附近</p><p>得到如下指针信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">bullet = [[PlayerActor+<span class="hljs-number">0x778</span>]+<span class="hljs-number">0x584</span>]<br>posi_x = [[PlayerActor+<span class="hljs-number">0x3A0</span>]+<span class="hljs-number">0x1A0</span>]<br>posi_y = [[PlayerActor+<span class="hljs-number">0x3A0</span>]+<span class="hljs-number">0x1A4</span>]<br>posi_z = [[PlayerActor+<span class="hljs-number">0x3A0</span>]+<span class="hljs-number">0x1A8</span>]<br>persp_x = [[PlayerActor+<span class="hljs-number">0x3A0</span>]+<span class="hljs-number">0x154</span>]<br>persp_y = [[PlayerActor+<span class="hljs-number">0x3A0</span>]+<span class="hljs-number">0x174</span>]<br></code></pre></td></tr></table></figure><p>基于上述信息，还能确定<code>ULevel</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ULevel = [UWorld+<span class="hljs-number">0x30</span>]<br></code></pre></td></tr></table></figure><p><code>ActorCount</code>和<code>ActorArray</code>的偏移可以使用CE的结构体分析功能</p><p><img src="assets/2023-11-12-19-16-56-image.png"></p><p>经过分析，确定<code>ActorCount</code>和<code>ActorArray</code>的偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">ActorCount = [ULevel+<span class="hljs-number">0xA0</span>]<br>ActorArray = [ULevel+<span class="hljs-number">0x98</span>]<br></code></pre></td></tr></table></figure><p>遍历<code>ActorArray</code>可以获得游戏内所有的Actor对象，包含了敌人对象，但还需要识别是否为敌人，所以还需要查找对象的Name</p><h4 id="CE分析GName"><a href="#CE分析GName" class="headerlink" title="CE分析GName"></a>CE分析GName</h4><p>UE4.23以下版本使用的GName算法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">BYTE *<span class="hljs-title function_">GetName</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span><br>&#123;<br>    <span class="hljs-type">int</span> idx0 = id / <span class="hljs-number">0x4000</span>;<br>    <span class="hljs-type">int</span> idx1 = id % <span class="hljs-number">0x4000</span>;<br>    BYTE *NameArray = [GName + idx0 * <span class="hljs-number">8</span>];<br>    BYTE *Name = [NameArray + idx1 * <span class="hljs-number">8</span>] + <span class="hljs-number">0xC</span>;<br>    <span class="hljs-keyword">return</span> Name;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用CE搜索进程内存，查找关键字符串<code>ByteProperty</code></p><p><img src="assets/2023-11-12-19-32-21-image.png"></p><p>如果上一个字符串为<code>None</code>，则表示搜索到了正确位置，此处为游戏对象的Name表</p><p>由于<code>ByteProperty</code>字符串id为1,可以根据<code>GetName</code>算法逆推GName</p><p>搜索地址<code>0x1E3D5EA0024-0xC</code></p><p><img src="assets/2023-11-12-19-35-24-image.png"></p><p>搜索<code>0x1E3D5E80008-1*8</code></p><p><img src="assets/2023-11-12-19-36-50-image.png"></p><p>搜索<code>0x1E3D5E70080</code></p><p><img src="assets/2023-11-12-19-37-47-image.png"></p><p>可以确定GName为<code>ShooterClient.exe+2D310B0</code>或<code>ShooterClient.exe+2E6E0C0</code></p><p>编写代码验证上述分析的偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    LPCWSTR procName = <span class="hljs-string">L&quot;ShooterClient.exe&quot;</span>;<br>    DWORD dwPID;<br>    HANDLE hProcess;<br>    LPVOID baseAddr;<br>    dwPID = getDwPidByName(procName);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PID: %d\n&quot;</span>, dwPID);<br>    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID);<br>    <span class="hljs-keyword">if</span> (hProcess == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open process failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    baseAddr = getModuleBase(dwPID);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;proc base: 0x%llx\n&quot;</span>, baseAddr);<br><br>    LPVOID UWorld;<br>    LPVOID GName;<br>    LPVOID GameInstance;<br>    LPVOID ULocalPlayer;<br>    LPVOID LocalPlayer;<br>    LPVOID PlayerController;<br>    LPVOID PlayerActor;<br>    LPVOID PlayerPosition;<br>    LPVOID ULevel;<br>    DWORD ActorCount;<br>    LPVOID ActorArray;<br>    <span class="hljs-comment">// 读取UWorld</span><br>    ReadProcessMemory(hProcess, (LPVOID)((BYTE*)baseAddr + <span class="hljs-number">0x02F71060</span>), (LPVOID)&amp;UWorld, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br>    ReadProcessMemory(hProcess, (LPVOID)((BYTE*)UWorld + <span class="hljs-number">0x160</span>), (LPVOID)&amp;GameInstance, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br>    ReadProcessMemory(hProcess, (LPVOID)((BYTE*)GameInstance + <span class="hljs-number">0x38</span>), (LPVOID)&amp;ULocalPlayer, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br>    ReadProcessMemory(hProcess, (LPVOID)ULocalPlayer, (LPVOID)&amp;LocalPlayer, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br>    ReadProcessMemory(hProcess, (LPVOID)((BYTE*)LocalPlayer + <span class="hljs-number">0x30</span>), (LPVOID)&amp;PlayerController, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br>    ReadProcessMemory(hProcess, (LPVOID)((BYTE*)PlayerController + <span class="hljs-number">0x3B0</span>), (LPVOID)&amp;PlayerActor, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;UWorld: 0x%llx\n&quot;</span>, UWorld);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;GameInstance: 0x%llx\n&quot;</span>, GameInstance);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ULocalPlayer: 0x%llx\n&quot;</span>, ULocalPlayer);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LocalPlayer: 0x%llx\n&quot;</span>, LocalPlayer);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PlayerController: 0x%llx\n&quot;</span>, PlayerController);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PlayerActor: 0x%llx\n&quot;</span>, PlayerActor);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    ReadProcessMemory(hProcess, (LPVOID)((BYTE*)UWorld + <span class="hljs-number">0x30</span>), (LPVOID)&amp;ULevel, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br>    ReadProcessMemory(hProcess, (LPVOID)((BYTE*)ULevel + <span class="hljs-number">0xA0</span>), (LPVOID)&amp;ActorCount, <span class="hljs-number">4</span>, <span class="hljs-literal">NULL</span>);<br>    ReadProcessMemory(hProcess, (LPVOID)((BYTE*)ULevel + <span class="hljs-number">0x98</span>), (LPVOID)&amp;ActorArray, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 读取玩家坐标</span><br>    FLOAT posi[<span class="hljs-number">3</span>];<br>    ReadProcessMemory(hProcess, (LPVOID)((BYTE*)PlayerActor + <span class="hljs-number">0x3A0</span>), (LPVOID)&amp;PlayerPosition, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br>    ReadProcessMemory(hProcess, (LPVOID)((BYTE*)PlayerPosition+<span class="hljs-number">0x1A0</span>), (LPVOID)posi, <span class="hljs-number">0xC</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;posi: [%f, %f, %f]\n&quot;</span>, posi[<span class="hljs-number">0</span>], posi[<span class="hljs-number">1</span>], posi[<span class="hljs-number">2</span>]);<br>    <span class="hljs-comment">// 读取玩家视角</span><br>    FLOAT persp_x, persp_y;<br>    ReadProcessMemory(hProcess, (LPVOID)((BYTE*)PlayerPosition + <span class="hljs-number">0x154</span>), (LPVOID)&amp;persp_x, <span class="hljs-number">0x4</span>, <span class="hljs-literal">NULL</span>);<br>    ReadProcessMemory(hProcess, (LPVOID)((BYTE*)PlayerPosition + <span class="hljs-number">0x174</span>), (LPVOID)&amp;persp_y, <span class="hljs-number">0x4</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;perspective: [%f, %f]\n&quot;</span>, persp_x, persp_y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ULevel: 0x%llx\n&quot;</span>, ULevel);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ActorCount: %d\n&quot;</span>, ActorCount);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ActorArray: 0x%llx\n&quot;</span>, ActorArray);<br>    <span class="hljs-comment">// 读取GName</span><br>    ReadProcessMemory(hProcess, (LPVOID)((BYTE*)baseAddr + <span class="hljs-number">0x2E6E0C0</span>), (LPVOID)&amp;GName, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;GName: 0x%llx\n&quot;</span>, GName);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-comment">// 遍历ActorArry</span><br>    <span class="hljs-keyword">for</span> (DWORD i = <span class="hljs-number">0</span>; i &lt; ActorCount; i++)<br>    &#123;<br>        LPVOID AActor;<br>        DWORD id;<br>        LPVOID PNameArray;<br>        LPVOID PName;<br>        CHAR name[<span class="hljs-number">0x100</span>];<br>        ReadProcessMemory(hProcess, (LPVOID)((BYTE*)ActorArray + i * <span class="hljs-number">8</span>), (LPVOID)&amp;AActor, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span> (ReadProcessMemory(hProcess, (LPVOID)((BYTE*)AActor + <span class="hljs-number">0x18</span>), (LPVOID)&amp;id, <span class="hljs-number">4</span>, <span class="hljs-literal">NULL</span>))<br>        &#123;<br>            ReadProcessMemory(hProcess, (LPVOID)((BYTE*)GName + (id / <span class="hljs-number">0x4000</span>) * <span class="hljs-number">8</span>), (LPVOID)&amp;PNameArray, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br>            ReadProcessMemory(hProcess, (LPVOID)((BYTE*)PNameArray + (id % <span class="hljs-number">0x4000</span>) * <span class="hljs-number">8</span>), (LPVOID)&amp;PName, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">if</span> (ReadProcessMemory(hProcess, (LPVOID)((BYTE*)PName + <span class="hljs-number">0xC</span>), (LPVOID)name, <span class="hljs-number">0x100</span>, <span class="hljs-literal">NULL</span>))<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: %s\n&quot;</span>, i, name);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="assets/2023-11-12-21-35-26-image.png"></p><p><img src="assets/2023-11-12-21-35-53-image.png"></p><p>玩家的坐标、视角都已经找到了，并且Actor对象的name识别也成功了，猜测<code>BotPawn_C</code>为机器人玩家的Actor对象，猜测其坐标算法与玩家相同，CE结构体分析</p><p><img src="assets/2023-11-12-21-39-37-image.png"></p><p><img src="assets/2023-11-12-21-40-18-image.png"></p><p><img src="assets/2023-11-12-21-40-50-image.png"></p><p>发现按照<code>Actor-&gt;0x3A0-&gt;0x1A0</code>的偏移确实可以找到机器人坐标</p><p>机器人玩家坐标计算如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">posi_x = [[AActor+<span class="hljs-number">0x3A0</span>]+<span class="hljs-number">0x1A0</span>]<br>posi_y = [[AActor+<span class="hljs-number">0x3A0</span>]+<span class="hljs-number">0x1A4</span>]<br>posi_z = [[AActor+<span class="hljs-number">0x3A0</span>]+<span class="hljs-number">0x1A8</span>]<br></code></pre></td></tr></table></figure><p>修改以下代码可以获取所有机器人玩家坐标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// printf(&quot;%d: %s\n&quot;, i, name);</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(name, <span class="hljs-string">&quot;BotPawn_C&quot;</span>))<br>&#123;<br>    LPVOID botPosition;<br>    FLOAT botPosi[<span class="hljs-number">3</span>];<br>    ReadProcessMemory(hProcess, (LPVOID)((BYTE*)AActor + <span class="hljs-number">0x3A0</span>), (LPVOID)&amp;botPosition, <span class="hljs-number">8</span>, <span class="hljs-literal">NULL</span>);<br>    ReadProcessMemory(hProcess, (LPVOID)((BYTE*)botPosition + <span class="hljs-number">0x1A0</span>), (LPVOID)botPosi, <span class="hljs-number">0xC</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bot: [%f, %f, %f] \n&quot;</span>, botPosi[<span class="hljs-number">0</span>], botPosi[<span class="hljs-number">1</span>], botPosi[<span class="hljs-number">2</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="assets/2023-11-12-21-47-33-image.png"></p><p>至此，已实现获取玩家坐标、玩家视角、敌人坐标的目标，对坐标数据进行数学处理，使用GUI工具绘制到屏幕上，即可实现透视效果，同样可以通过计算玩家视角需要转动的角度，实现自瞄的功能。</p><h3 id="外挂分析"><a href="#外挂分析" class="headerlink" title="外挂分析"></a>外挂分析</h3><h5 id="VMP脱壳DUMP"><a href="#VMP脱壳DUMP" class="headerlink" title="VMP脱壳DUMP"></a>VMP脱壳DUMP</h5><p><img src="assets/2023-11-12-21-54-21-image.png"></p><p>入口push call，典型vmp，使用API断点回溯确定程序逻辑是否加密</p><p>根据外挂实现原理，读取进程需要使用<code>ReadProcessMemory</code>API，而这之前还需要使用<code>OpenProcess</code>API打开进程，<code>OpenProcess</code>需要的参数为进程PID，但是该外挂程序不需要提供PID，因此该外挂运行早期会使用某些方式获取目标游戏的PID，需要利用<code>Thelp32</code>功能，对<code>CreateThelp32Snapshot</code>下断点</p><p><img src="assets/2023-11-12-22-00-29-image.png"></p><p>ScyllaHide过VMP反调试</p><p><img src="assets/2023-11-12-22-01-03-image.png"></p><p>3处nop断下后F9运行</p><p><img src="assets/2023-11-12-22-02-08-image.png"></p><p>Thelp32断下，第一次是VMP反调试调用的，忽略掉，F9运行</p><p><img src="assets/2023-11-12-22-02-51-image.png"></p><p>Thelp32第二次断下，分析调用栈回溯</p><p><img src="assets/2023-11-12-22-18-27-image.png"></p><p>发现此处为典型的msvc编译器主函数调用入口</p><p><img src="assets/2023-11-12-22-19-12-image.png"></p><p>因此该层为<code>start</code>，可以确定程序逻辑未加密，向上找到程序入口点<code>OEP</code></p><p><img src="assets/2023-11-12-22-19-42-image.png"></p><p>对OEP下断点，取消Thelp32断点，重新运行程序，3次nop之后OEP断下</p><p><img src="assets/2023-11-12-22-20-50-image.png"></p><p>使用Scylla插件DUMP外挂内存</p><p><img src="assets/2023-11-12-22-23-19-image.png"></p><p>使用Fix Dump修复DUMP文件的导入数据</p><p><img src="assets/2023-11-12-22-24-07-image.png"></p><p>删除带X的FThunk</p><p>运行恢复后的DUMP文件<code>hack_dump_SCY.exe</code>，外挂功能正常</p><p><img src="assets/2023-11-12-22-29-08-image.png"></p><p>外挂脱壳完成</p><h5 id="外挂逻辑分析"><a href="#外挂逻辑分析" class="headerlink" title="外挂逻辑分析"></a>外挂逻辑分析</h5><p>使用IDA Pro打开脱壳后的<code>hack_dump_SYC.exe</code>分析逻辑，动态调试之后对主函数注释如下，程序中的字符串大部分被加密，算法比较简单，但是使用动态调试也可以直接得到解密之后的字符串</p><p><img src="assets/2023-11-12-22-31-52-image.png"></p><p>主要功能就是打开游戏进程，获取游戏加载地址，创建窗口等操作，API断点回溯时断下的位置在<code>GetPidByName</code>函数中</p><p><img src="assets/2023-11-12-22-33-30-image.png"></p><p>作弊的主要逻辑在<code>CheatProc</code>过程函数中</p><p><img src="assets/2023-11-12-22-34-29-image.png"></p><p><code>showGUI</code>函数调用<code>imGUI</code>库在屏幕上显示窗口</p><p><img src="assets/2023-11-12-22-35-51-image.png"></p><p>这里使用<code>GetAsyncKeyState</code>API判断HOME键是否被按下，HOME按下之后切换GUI显示状态</p><p><img src="assets/2023-11-12-22-38-55-image.png"></p><p><code>CheatMain</code>里第一个和最后一个函数是用来刷新屏幕上显示的文本标签的，可以直接忽略</p><p>继续进入到<code>cheatMain</code>函数，这里是主要的外观逻辑实现</p><p><img src="assets/2023-11-12-22-40-45-image.png"></p><p><img src="assets/2023-11-12-22-40-59-image.png"></p><p>首先使用<code>ReadProcessMemory</code>API读取进程内存，获取<code>UWorld</code>，<code>GName</code>等数据，偏移的计算在游戏分析部分得到的偏移基本相同，对所有的全局变量进行注释，方便后续分析</p><p><img src="assets/2023-11-12-22-43-32-image.png"></p><p><img src="assets/2023-11-12-22-44-46-image.png"></p><p><img src="assets/2023-11-12-22-44-35-image.png"></p><p>遍历游戏中所有的Actor对象，并且获取对象的name，与<code>BotPawn_C</code>进行比较，判断该AActor是否为机器人</p><p><img src="assets/2023-11-12-22-46-13-image.png"></p><p>是机器人时读取机器人坐标，根据玩家坐标、窗口分辨率计算是否在屏幕显示范围内，是的话则会在屏幕上显示玩家与机器人的距离</p><p>此部分还计算了机器人在屏幕上显示坐标与窗口中心的距离，循环结束后保持与屏幕中心距离最近的机器人坐标，用于自瞄功能</p><p><img src="assets/2023-11-12-22-49-57-image.png"></p><p>自瞄功能同样使用<code>GetAsyncKeyState</code>判断按键是否按下，这里判断的是鼠标右键，当鼠标右键按下时，修改玩家视角使其瞄向距离屏幕中心最近的机器人</p><p>至此，外挂程序功能分析完成。</p>]]></content>
    
    
    <categories>
      
      <category>腾讯游戏客户端安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>拟态2023-RE</title>
    <link href="/2023/11/12/ctf_wp/%E6%8B%9F%E6%80%812023-RE/"/>
    <url>/2023/11/12/ctf_wp/%E6%8B%9F%E6%80%812023-RE/</url>
    
    <content type="html"><![CDATA[<h3 id="fisher"><a href="#fisher" class="headerlink" title="fisher"></a>fisher</h3><p>各种反调试检测</p><ul><li><p>vmtoolsd.exe</p><p><img src="assets/2023-11-12-10-29-04-image.png"></p></li><li><p>NtQueryInformationProcess</p><p><img src="assets/2023-11-12-10-29-42-image.png"></p><p><img src="assets/2023-11-12-10-31-19-image.png"></p></li><li><p>花指令</p><p><img src="assets/2023-11-12-10-39-27-image.png"></p><p><img src="assets/2023-11-12-10-39-46-image.png"></p><p><img src="assets/2023-11-12-10-32-36-image.png"></p></li><li><p>随机数干扰</p><p><img src="assets/2023-11-12-10-41-08-image.png"></p></li></ul><p>把反调试全部patch掉</p><p>很多的函数里对输入数据都做sha1校验，输入数据的sha1校验结果需要为<code>2e95a5c5f9643df668d3965a6cdf19541bc0496b</code></p><p><img src="assets/2023-11-12-10-40-28-image.png"></p><p>看了好久没找到sha1突破点</p><p>一开始只看了反编译c代码，被错误的输出干扰了</p><p><img src="assets/2023-11-12-10-33-35-image.png"></p><p>需要注意try catch</p><p><img src="assets/2023-11-12-10-34-09-image.png"></p><p><img src="assets/2023-11-12-10-35-08-image.png"></p><p>try里面做了sha1校验，当校验通过时会抛出异常，进入到catch块，校验不通过返回0</p><p>突破点在catch块内，看catch块的末尾可以找到输出字符串的部分</p><p><img src="assets/2023-11-12-10-45-08-image.png"></p><p>左边是正确时的输出，字符串解密之后是<code>you win! your flag: flag&#123;your input&#125;</code></p><p>核心的加密运算在<code>call [rax+0x18]</code>，加密完跟<code>N17EHf1DWHD40DWH/f79E05EfIH1E179E1</code>字符串比较</p><p><img src="assets/2023-11-12-10-47-19-image.png"></p><p>函数里面第一个大循环把输入拷贝了一遍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c">v20 = (BYTE *)Src[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> ( v4 != v3 )<br>&#123;<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    v21 = &amp;v3[(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)v18];<br>    <span class="hljs-keyword">if</span> ( v20 == v48 )<br>    &#123;<br>      sub_7FF6786A9B10((<span class="hljs-type">const</span> <span class="hljs-type">void</span> **)Src, v20, v21);<br>      v22 = (BYTE *)Src[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      *v20 = *v21;<br>      v22 = (BYTE *)++Src[<span class="hljs-number">1</span>];<br>    &#125;<br>    v18 = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(v18 + <span class="hljs-number">1</span>);<br>    a1 = v49;<br>    <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)v18 == *((_QWORD *)&amp;v49 + <span class="hljs-number">1</span>) - (_QWORD)v49 )<br>      <span class="hljs-keyword">break</span>;<br>    v23 = *(_BYTE *)(v49 + v18);<br>    <span class="hljs-keyword">if</span> ( v23 == *((_BYTE *)Src[<span class="hljs-number">0</span>] + v19) )    <span class="hljs-comment">// 后一个字符与前一个字符相同，填充X</span><br>    &#123;<br>      v41[<span class="hljs-number">0</span>] = <span class="hljs-number">88</span>;<br>      <span class="hljs-keyword">if</span> ( v22 == v48 )<br>      &#123;<br>        sub_7FF6786A9B10((<span class="hljs-type">const</span> <span class="hljs-type">void</span> **)Src, v22, v41);<br>        v20 = (BYTE *)Src[<span class="hljs-number">1</span>];<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        *v22 = <span class="hljs-number">88</span>;<br>        v20 = (BYTE *)++Src[<span class="hljs-number">1</span>];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ( v22 == v48 )<br>      &#123;<br>        sub_7FF6786A9B10((<span class="hljs-type">const</span> <span class="hljs-type">void</span> **)Src, v22, (_BYTE *)(v49 + v18));<br>        v20 = (BYTE *)Src[<span class="hljs-number">1</span>];<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        *v22 = v23;<br>        v20 = (BYTE *)++Src[<span class="hljs-number">1</span>];<br>      &#125;<br>      LODWORD(v18) = v18 + <span class="hljs-number">1</span>;<br>    &#125;<br>    v19 += <span class="hljs-number">2</span>;<br>    v3 = (BYTE *)v49;<br>    a1 = *((_QWORD *)&amp;v49 + <span class="hljs-number">1</span>) - v49;<br>    <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> __int64)(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)v18 &gt;= *((_QWORD *)&amp;v49 + <span class="hljs-number">1</span>) - (_QWORD)v49 )<br>      <span class="hljs-keyword">goto</span> LABEL_42;<br>  &#125;<br>  v41[<span class="hljs-number">0</span>] = <span class="hljs-number">88</span>;<br>  <span class="hljs-keyword">if</span> ( v22 == v48 )                           <span class="hljs-comment">// 长度为奇数，末尾补X</span><br>  &#123;<br>    sub_7FF6786A9B10((<span class="hljs-type">const</span> <span class="hljs-type">void</span> **)Src, v22, v41);<br>    v20 = (BYTE *)Src[<span class="hljs-number">1</span>];<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    *v22 = <span class="hljs-number">88</span>;<br>    v20 = (BYTE *)++Src[<span class="hljs-number">1</span>];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二个大循环对输入字符串做了一些处理，按两个字符一组，忽略字符表以外的字符，第一个字符和第二字符相同时在中间加<code>X</code>，字符串长度为奇数末尾加<code>X</code></p><p>字符表<code>ghijklpqrstuvwxyzABCabcDEFdef0123GHI4567JKL+/MNOmnoPQRSXYZ8TUVW9</code></p><p>接下来核心加密部分</p><p><img src="assets/2023-11-12-10-51-07-image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-keyword">do</span><br>    &#123;<br>      v10 = *((_BYTE *)*a2 + v6);<br>      sub_7FF6786AA6D3(<span class="hljs-number">2</span>i64, (__int64)a2);<br>      v11 = <span class="hljs-number">0</span>;<br>      v12 = <span class="hljs-number">0</span>i64;<br>      v13 = a1 + <span class="hljs-number">9</span>;<br>      <span class="hljs-keyword">while</span> ( <span class="hljs-number">2</span> )<br>      &#123;<br>        v14 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>i64; i &lt; <span class="hljs-number">8</span>; ++i )<br>        &#123;<br>          <span class="hljs-keyword">if</span> ( v10 == *((_BYTE *)v13 + i) )<br>          &#123;<br>            i1 = v11;<br>            i_ = v12;<br>            j1 = v14;<br>            <span class="hljs-keyword">goto</span> LABEL_10;<br>          &#125;<br>          ++v14;<br>        &#125;<br>        ++v11;<br>        ++v12;<br>        ++v13;<br>        <span class="hljs-keyword">if</span> ( v12 &lt; <span class="hljs-number">8</span> )<br>          <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>LABEL_10:<br>      v16 = v6 + <span class="hljs-number">1</span>;<br>      v17 = *((_BYTE *)*a2 + v16);<br>      sub_7FF6786AA6D3(<span class="hljs-number">2</span>i64, (__int64)v13);<br>      v18 = <span class="hljs-number">0</span>;<br>      v19 = <span class="hljs-number">0</span>i64;<br>      v20 = a1 + <span class="hljs-number">9</span>;<br>      <span class="hljs-keyword">while</span> ( <span class="hljs-number">2</span> )<br>      &#123;<br>        v21 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>i64; j &lt; <span class="hljs-number">8</span>; ++j )<br>        &#123;<br>          <span class="hljs-keyword">if</span> ( v17 == *((_BYTE *)v20 + j) )<br>          &#123;<br>            i2 = v18;<br>            j2 = v21;<br>            <span class="hljs-keyword">goto</span> LABEL_17;<br>          &#125;<br>          ++v21;<br>        &#125;<br>        ++v18;<br>        ++v19;<br>        ++v20;<br>        <span class="hljs-keyword">if</span> ( v19 &lt; <span class="hljs-number">8</span> )<br>          <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>LABEL_17:<br>      <span class="hljs-keyword">if</span> ( i1 == i2 )<br>      &#123;<br>        v23 = <span class="hljs-number">8</span> * i_ + <span class="hljs-number">72</span>;<br>        v24 = (<span class="hljs-type">char</span> *)a1 + v23 + (<span class="hljs-type">int</span>)(j1 + <span class="hljs-number">1</span>) % <span class="hljs-number">8</span>;<br>        v25 = *(_BYTE **)(a3 + <span class="hljs-number">8</span>);<br>        <span class="hljs-keyword">if</span> ( v25 == *(_BYTE **)(a3 + <span class="hljs-number">16</span>) )<br>        &#123;<br>          sub_7FF6786A9B10((<span class="hljs-type">const</span> <span class="hljs-type">void</span> **)a3, v25, v24);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>          *v25 = *v24;<br>          ++*(_QWORD *)(a3 + <span class="hljs-number">8</span>);<br>        &#125;<br>        sub_7FF6786AA6D3(<span class="hljs-number">2</span>i64, (__int64)v25);<br>        v26 = (<span class="hljs-type">char</span> *)a1 + v23 + (j2 + <span class="hljs-number">1</span>) % <span class="hljs-number">8</span>;<br>        a2 = *(<span class="hljs-type">void</span> ***)(a3 + <span class="hljs-number">8</span>);<br>        <span class="hljs-keyword">if</span> ( a2 == *(<span class="hljs-type">void</span> ***)(a3 + <span class="hljs-number">16</span>) )<br>        &#123;<br>          sub_7FF6786A9B10((<span class="hljs-type">const</span> <span class="hljs-type">void</span> **)a3, a2, v26);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>          *(_BYTE *)a2 = *v26;<br>          ++*(_QWORD *)(a3 + <span class="hljs-number">8</span>);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        v27 = *a1;<br>        <span class="hljs-keyword">if</span> ( j1 == j2 )<br>          (*(<span class="hljs-type">void</span> (__fastcall **)(__int64 *, _QWORD, __int64, _QWORD, <span class="hljs-type">int</span>))v27)(a1, j1, a3, i1, i2);<br>        <span class="hljs-keyword">else</span><br>          (*(<span class="hljs-type">void</span> (__fastcall **)(__int64 *, _QWORD, _QWORD, __int64, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>))(v27 + <span class="hljs-number">8</span>))(a1, i1, j1, a3, i2, j2);<br>      &#125;<br>      v6 = v16 + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> ( v6 &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)len );<br></code></pre></td></tr></table></figure><p>在while循环里，两个字符一组，查字符表索引，每个字符对应两个索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">index = <span class="hljs-number">8</span> * i + j<br></code></pre></td></tr></table></figure><p>用python还原一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">table = <span class="hljs-string">&quot;ghijklpqrstuvwxyzABCabcDEFdef0123GHI4567JKL+/MNOmnoPQRSXYZ8TUVW9&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">enc</span>(<span class="hljs-params">c1, c2</span>):<br>    i1 = table.index(c1) // <span class="hljs-number">8</span><br>    j1 = table.index(c1) % <span class="hljs-number">8</span><br>    i2 = table.index(c2) // <span class="hljs-number">8</span><br>    j2 = table.index(c2) % <span class="hljs-number">8</span><br>    <span class="hljs-keyword">if</span> (i1 == i2):<br>        indx1 = <span class="hljs-number">8</span> * i1 + (j1 + <span class="hljs-number">1</span>) % <span class="hljs-number">8</span><br>        indx2 = <span class="hljs-number">8</span> * i2 + (j2 + <span class="hljs-number">1</span>) % <span class="hljs-number">8</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> (j1 == j2):<br>            indx1 = <span class="hljs-number">8</span> * ((i1 + <span class="hljs-number">1</span>) % <span class="hljs-number">8</span>) + j1<br>            indx2 = <span class="hljs-number">8</span> * ((i2 + <span class="hljs-number">1</span>) % <span class="hljs-number">8</span>) + j2<br>        <span class="hljs-keyword">else</span>:<br>            indx1 = <span class="hljs-number">8</span> * i1 + j2<br>            indx2 = <span class="hljs-number">8</span> * i2 + j1<br>    <span class="hljs-keyword">return</span> table[indx1]+table[indx2]<br><br></code></pre></td></tr></table></figure><p>要根据两个字符的ij情况分类做替换，写出逆过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dec</span>(<span class="hljs-params">c1, c2</span>):<br>    i1 = table.index(c1) // <span class="hljs-number">8</span><br>    j1 = table.index(c1) % <span class="hljs-number">8</span><br>    i2 = table.index(c2) // <span class="hljs-number">8</span><br>    j2 = table.index(c2) % <span class="hljs-number">8</span><br>    <span class="hljs-keyword">if</span> (i1 == i2):<br>        indx1 = <span class="hljs-number">8</span> * i1 + (j1 - <span class="hljs-number">1</span>) % <span class="hljs-number">8</span><br>        indx2 = <span class="hljs-number">8</span> * i2 + (j2 - <span class="hljs-number">1</span>) % <span class="hljs-number">8</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> (j1 == j2):<br>            indx1 = <span class="hljs-number">8</span> * ((i1 - <span class="hljs-number">1</span>) % <span class="hljs-number">8</span>) + j1<br>            indx2 = <span class="hljs-number">8</span> * ((i2 - <span class="hljs-number">1</span>) % <span class="hljs-number">8</span>) + j2<br>        <span class="hljs-keyword">else</span>:<br>            indx1 = <span class="hljs-number">8</span> * i1 + j2<br>            indx2 = <span class="hljs-number">8</span> * i2 + j1<br>    <span class="hljs-keyword">return</span> table[indx1]+table[indx2]<br><br>flag = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(ans), <span class="hljs-number">2</span>):<br>    flag += dec(ans[i], ans[i+<span class="hljs-number">1</span>])<br><br><span class="hljs-built_in">print</span>(flag)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(flag), <span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">print</span>(enc(flag[i], flag[i+<span class="hljs-number">1</span>]), end=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-built_in">print</span>(ans)<br><br></code></pre></td></tr></table></figure><p>跑一下得到下面的flag</p><p><code>6c324d2c86a72b864a2X2f30e46d202X20</code></p><p>算hash不对，根据前面补<code>X</code>的规则，把两个<code>X</code>去掉</p><p><img src="assets/2023-11-12-10-57-44-image.png"></p><p>ack，得到flag<code>flag&#123;6c324d2c86a72b864a22f30e46d20220&#125;</code></p>]]></content>
    
    
    <categories>
      
      <category>ctf-wp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>外挂实现分析-移动端</title>
    <link href="/2023/11/12/TencentGameClient/%E5%A4%96%E6%8C%82%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90-%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    <url>/2023/11/12/TencentGameClient/%E5%A4%96%E6%8C%82%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90-%E7%A7%BB%E5%8A%A8%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/noxke/TencentGameClientOpenCourse">GitHub - noxke&#x2F;TencentGameClientOpenCourse: 腾讯游戏客户端公开课2023 腾讯菁英班</a></p><h3 id="游戏分析"><a href="#游戏分析" class="headerlink" title="游戏分析"></a>游戏分析</h3><p>使用工具如下:</p><blockquote><p>root设备(nikel lineageos14 Android7.1.2)</p><p><a href="https://github.com/Perfare/Il2CppDumper">Il2CppDumper v6.7.40</a></p><p><a href="https://github.com/dnSpy/dnSpy">dnSpy v6.1.8</a></p><p><a href="https://hex-rays.com/IDA-pro/">IDA Pro 7.7</a></p><p><a href="https://bbs.binmt.cc/forum-2-1.html">mt文件管理器</a></p><p><a href="https://github.com/frida/frida">friad 16.1.4</a></p></blockquote><p>安装FlappyBird.apk进行测试</p><p><img src="assets/2023-10-28-22-29-44-image.png"></p><p>看来安卓版本太高还不让装，添加<code>android:exported=&#39;true&#39;</code>之后虽然能装上，但是启动黑屏，老老实实用低版本安卓分析算了</p><p>由于是Unity游戏，没必要分析Java层，直接查看libs文件价下的lib文件</p><p><img src="assets/2023-10-28-22-32-56-image.png"></p><p>看到<code>libil2cpp.so</code>文件，显然，这道题使用的是Unity il2cpp的方式，游戏逻辑在<code>libil2cpp.so</code>文件中，没有函数导出符号，分析难度较大。</p><p>从apk中提取处<code>libil2cpp.so</code>和<code>global-metadata.dat</code>，使用Il2CppDumper工具提取符号信息</p><p><img src="assets/2023-10-28-22-40-25-image.png"></p><p>提取得到的文件有<code>DummyDll</code>下的DLL文件，<code>il2cpp.h</code>结构体信息，<code>script.json</code>符号信息，<code>DummyDll</code>下的<code>Assembly-CSharp.dll</code>可以用dnSpy打开，分析C#类方法和成员，但是只有符号信息，没有方法实现</p><p>分析一下类名，可以知道玩家控制的逻辑在<code>PlayerController</code>类中实现，游戏控制和计分逻辑在<code>GameManager</code>类中实现</p><p><code>PlayerController</code>类中需要关注以下几个方法</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-comment">// Token: 0x0600002C RID: 44 RVA: 0x00002050 File Offset: 0x00000250</span><br>[<span class="hljs-meta">Token(Token = <span class="hljs-string">&quot;0x600001A&quot;</span>)</span>]<br>[<span class="hljs-meta">Address(RVA = <span class="hljs-string">&quot;0x5E23E4&quot;</span>, Offset = <span class="hljs-string">&quot;0x5E23E4&quot;</span>, VA = <span class="hljs-string">&quot;0x5E23E4&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>&#125;<br><br><span class="hljs-comment">// Token: 0x0600002D RID: 45 RVA: 0x00002050 File Offset: 0x00000250</span><br>[<span class="hljs-meta">Token(Token = <span class="hljs-string">&quot;0x600001B&quot;</span>)</span>]<br>[<span class="hljs-meta">Address(RVA = <span class="hljs-string">&quot;0x5E2788&quot;</span>, Offset = <span class="hljs-string">&quot;0x5E2788&quot;</span>, VA = <span class="hljs-string">&quot;0x5E2788&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>()</span><br>&#123;<br>&#125;<br><br><span class="hljs-comment">// Token: 0x0600002E RID: 46 RVA: 0x00002050 File Offset: 0x00000250</span><br>[<span class="hljs-meta">Token(Token = <span class="hljs-string">&quot;0x600001C&quot;</span>)</span>]<br>[<span class="hljs-meta">Address(RVA = <span class="hljs-string">&quot;0x5E2A70&quot;</span>, Offset = <span class="hljs-string">&quot;0x5E2A70&quot;</span>, VA = <span class="hljs-string">&quot;0x5E2A70&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D col</span>)</span><br>&#123;<br>&#125;<br><br><span class="hljs-comment">// Token: 0x0600002F RID: 47 RVA: 0x00002050 File Offset: 0x00000250</span><br>[<span class="hljs-meta">Token(Token = <span class="hljs-string">&quot;0x600001D&quot;</span>)</span>]<br>[<span class="hljs-meta">Address(RVA = <span class="hljs-string">&quot;0x5E30C8&quot;</span>, Offset = <span class="hljs-string">&quot;0x5E30C8&quot;</span>, VA = <span class="hljs-string">&quot;0x5E30C8&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter2D</span>(<span class="hljs-params">Collision2D col</span>)</span><br>&#123;<br>&#125;<br><br><span class="hljs-comment">// Token: 0x06000030 RID: 48 RVA: 0x00002050 File Offset: 0x00000250</span><br>[<span class="hljs-meta">Token(Token = <span class="hljs-string">&quot;0x600001E&quot;</span>)</span>]<br>[<span class="hljs-meta">Address(RVA = <span class="hljs-string">&quot;0x5E2FAC&quot;</span>, Offset = <span class="hljs-string">&quot;0x5E2FAC&quot;</span>, VA = <span class="hljs-string">&quot;0x5E2FAC&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">KillPlayer</span>()</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>GameManager</code>类中需要关注<code>UpdateScore</code>方法</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-comment">// GameManager</span><br><span class="hljs-comment">// Token: 0x06000006 RID: 6 RVA: 0x00002050 File Offset: 0x00000250</span><br>[<span class="hljs-meta">Token(Token = <span class="hljs-string">&quot;0x6000006&quot;</span>)</span>]<br>[<span class="hljs-meta">Address(RVA = <span class="hljs-string">&quot;0x5E09BC&quot;</span>, Offset = <span class="hljs-string">&quot;0x5E09BC&quot;</span>, VA = <span class="hljs-string">&quot;0x5E09BC&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateScore</span>()</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述方法的实现都在<code>libil2cpp.so</code>文件中，下面使用ida32分析该文件</p><p>使用idapython加载<code>Il2CppDumper</code>的<code>ida_with_struct_py3.py</code>脚本，选择<code>script.json</code>和<code>il2cpp.h</code>文件，恢复函数名和结构体</p><ul><li><p><code>PlayerController__Update</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PlayerController__Update</span><span class="hljs-params">(PlayerController_o *<span class="hljs-keyword">this</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>-&gt;fields.start )<br>    &#123;<br>        tiltSmooth = <span class="hljs-keyword">this</span>-&gt;fields.tiltSmooth;<br>        <span class="hljs-built_in">UnityEngine_Quaternion__Lerp</span>(&amp;v32, v33[<span class="hljs-number">0</span>], v28, tiltSmooth * deltaTime, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">UnityEngine_Transform__set_rotation</span>(transform, v32, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">UnityEngine_Transform__set_localPosition</span>(v16, v34, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">UnityEngine_Transform__set_rotation</span>(v17, v29, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要是设置旋转，设置位置</p></li><li><p><code>PlayerController__LateUpdate</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PlayerController__LateUpdate</span><span class="hljs-params">(PlayerController_o*<span class="hljs-keyword">this</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Instance-&gt;fields.start &amp;&amp; <span class="hljs-built_in">UnityEngine_Input__GetMouseButtonDown</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>        <span class="hljs-built_in">UnityEngine_Rigidbody2D__set_gravityScale</span>(<span class="hljs-keyword">this</span>-&gt;fields.playerRigid, <span class="hljs-number">1.0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">this</span>-&gt;fields.tiltSmooth = <span class="hljs-keyword">this</span>-&gt;fields.minTiltSmooth;<br>        <span class="hljs-built_in">UnityEngine_Transform__set_rotation</span>(transform, <span class="hljs-keyword">this</span>-&gt;fields.upRotation, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">UnityEngine_Vector2__get_zero</span>(&amp;value, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">UnityEngine_Rigidbody2D__set_velocity</span>(playerRigid, value, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">UnityEngine_Vector2__get_up</span>(&amp;v11, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">UnityEngine_Vector2__op_Multiply_2987556</span>(&amp;force, v11, <span class="hljs-keyword">this</span>-&gt;fields.thrust, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">UnityEngine_Rigidbody2D__AddForce</span>(v7, force, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">UnityEngine_Rigidbody2D__get_velocity</span>(&amp;value, <span class="hljs-keyword">this</span>-&gt;fields.playerRigid, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (value.fields.y &lt; <span class="hljs-number">-1.0</span>)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;fields.tiltSmooth = <span class="hljs-keyword">this</span>-&gt;fields.maxTiltSmooth;<br>        <span class="hljs-built_in">UnityEngine_Rigidbody2D__set_gravityScale</span>(v9, <span class="hljs-number">2.0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数的内容相对就多一些类，但是根据函数名很容易分析出功能，主要是两个if内的内容，第一个if当屏幕被点击时进入，把小鸟的刚体组件重力影响<code>gravityScale</code>修改为1.0，将刚体组件的速度向量<code>velocity</code>设置为0，为刚体组件施加一个y反向的力，大小为<code>this-&gt;fields.thrust</code>，该部分的目的是让小鸟有一个向上的速度；第二个if先判断向下的速度，当向下速度小于1.0时增大刚体的重力影响</p></li><li><p><code>PlayerController__OnTriggerEnter2D</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PlayerController__OnTriggerEnter2D</span><span class="hljs-params">(PlayerController_o*<span class="hljs-keyword">this</span>, UnityEngine_Collider2D_o* col)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UnityEngine_Component__CompareTag</span>(transform, (System_String_o*)StringLiteral_3006, <span class="hljs-number">0</span>))<br>    &#123;<br>        <span class="hljs-built_in">GameManager__UpdateScore</span>(GameManager_TypeInfo-&gt;static_fields-&gt;Instance, v7);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UnityEngine_Component__CompareTag</span>(v8, (System_String_o*)StringLiteral_3014, <span class="hljs-number">0</span>))<br>        &#123;<br>            <span class="hljs-built_in">PlayerController__KillPlayer</span>(<span class="hljs-keyword">this</span>, v29);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要是两个<code>CompareTag</code>，第一个<code>CompareTag</code>比较进入的物体是否为<code>Score</code>，如果是<code>Score</code>则调用<code>GameManager__UpdateScore</code>更新游戏分数，第二个<code>CompareTag</code>比较进入的物体是否为<code>Obstacle</code>，如果是<code>Obstacle</code>则调用<code>PlayerController__KillPlayer</code>触发死亡</p></li><li><p><code>PlayerController__OnCollisionEnter2D</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PlayerController__OnCollisionEnter2D</span><span class="hljs-params">(PlayerController_o*<span class="hljs-keyword">this</span>, UnityEngine_Collision2D_o* col,)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UnityEngine_Component__CompareTag</span>(transform, (System_String_o*)StringLiteral_3015, <span class="hljs-number">0</span>))<br>    &#123;<br>        <span class="hljs-built_in">PlayerController__KillPlayer</span>(<span class="hljs-keyword">this</span>, v6);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只有一个<code>CompareTag</code>，比较碰撞的物体是否为<code>Ground</code>，是<code>Ground</code>则调用<code>PlayerController__KillPlayer</code>触发死亡</p></li><li><p><code>PlayerController__KillPlayer</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> __fastcall <span class="hljs-title">PlayerController__KillPlayer</span><span class="hljs-params">(PlayerController_o *<span class="hljs-keyword">this</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">GameManager__EndGame</span>(GameManager_TypeInfo-&gt;static_fields-&gt;Instance, method);<br>    <span class="hljs-built_in">UnityEngine_Vector2__get_zero</span>(&amp;v5, <span class="hljs-number">0</span>);    <br>    <span class="hljs-built_in">UnityEngine_Rigidbody2D__set_velocity</span>(playerRigid, v5, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>GameManager__EndGame</code>结束游戏，将小鸟刚体速度向量设置为0</p></li><li><p><code>GameManager__UpdateScore</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GameManager__UpdateScore</span><span class="hljs-params">(GameManager_o *<span class="hljs-keyword">this</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    gameScoreText = <span class="hljs-keyword">this</span>-&gt;fields.gameScoreText;<br>    v4 = <span class="hljs-keyword">this</span>-&gt;fields.gameScore + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">this</span>-&gt;fields.gameScore = v4;<br>    <span class="hljs-built_in">SoundManager__PlayTheAudio</span>(SoundManager_TypeInfo-&gt;static_fields-&gt;Instance, (System_String_o*)StringLiteral_3005, v8);<br>&#125;<br></code></pre></td></tr></table></figure><p>分数+1，刷新分数显示，播放音乐</p></li></ul><h4 id="Patch二进制文件破解"><a href="#Patch二进制文件破解" class="headerlink" title="Patch二进制文件破解"></a>Patch二进制文件破解</h4><p>在上面分析里面可以知道有两个<code>CompareTag</code>分支会触发死亡，只要Patch掉这两个分支，就可以轻松实现无敌效果，至于能不能关闭小鸟与管道的碰撞，可以猜测管道属于<code>Obstacle</code>，地面属于<code>Ground</code>，因此小鸟可以穿过管道，但是不会穿过地面</p><p>汇编界面查看这两个分支</p><img src="assets/2023-10-28-23-39-22-image.png" title="" alt="" width="522"><p>这里是<code>PlayerController__OnTriggerEnter2D</code>的死亡分支，比较进入的物体是否为<code>Obstacle</code>，当比较结果不为1时调整到函数末尾返回，否则进入后续代码触发死亡，将BNE修改为B指令即可</p><img src="assets/2023-10-28-23-43-09-image.png" title="" alt="" width="525"><p>继续查看<code>PlayerController__OnCollisionEnter2D</code>中的<code>CompareTag</code>分支，与上面的情况类似，将BNE修改为B指令</p><img src="assets/2023-10-28-23-45-02-image.png" title="" alt="" width="526"><p>分数的更新在<code>GameManager__UpdateScore</code>中，将分数加一进行修改即可实现修改游戏分数，修改如下，将加一修改为加0xFF</p><img title="" src="assets/2023-10-28-23-50-33-image.png" alt="" width="523"><p>保存修改并上传到手机</p><p><img src="assets/2023-10-28-23-52-41-image.png"></p><p>使用mt文件管理器将修改后的libil2cpp.so添加到apk中重新打包签名</p><img src="assets/2023-10-28-23-54-55-image.png" title="" alt="" width="246"><p>安装测试</p><img title="" src="assets/2023-10-28-23-56-45-image.png" alt="" width="241"><p>无论是碰撞地面还是管道，都不会死亡，并且一次得分为255分，游戏破解完成</p><h4 id="frida一把梭"><a href="#frida一把梭" class="headerlink" title="frida一把梭"></a>frida一把梭</h4><p>将frida-server上传到手机，编写python脚本附加到游戏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">on_message</span>(<span class="hljs-params">message, data</span>):<br>    <span class="hljs-keyword">if</span> message[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;send&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] &#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(message[<span class="hljs-string">&#x27;payload&#x27;</span>]))<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(message)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    device = frida.get_usb_device()<br>    app = device.get_frontmost_application()<br>    process = device.attach(app.pid)<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">True</span>):<br>        jscode = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[0] : 退出&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[1] : 开启无敌&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[2] : 关闭无敌&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[3] : 开启飞行&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[4] : 关闭飞行&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[5] : 加分数&quot;</span>)<br>        <span class="hljs-comment"># print(&quot;[9] : hook测试&quot;)</span><br>        choice = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;&gt;&gt; &quot;</span>))<br>        <span class="hljs-keyword">match</span> choice:<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                jscode = invincible_js<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                jscode = off_invincible_js<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                jscode = fly_js<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                jscode = off_fly_js<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                jscode = add_score_js<br>            <span class="hljs-comment"># case 9:</span><br>            <span class="hljs-comment">#     jscode = hook_js</span><br>            <span class="hljs-keyword">case</span> _:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入错误&quot;</span>)<br>        script = process.create_script(jscode)<br>        script.on(<span class="hljs-string">&#x27;message&#x27;</span>, on_message)<br>        script.load()<br><br>    process.detach()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>实现的功能有无敌、飞行和加分数，下面分别分析frida脚本内容</p><ul><li><p>开启无敌</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">var</span> libil2cpp = <span class="hljs-title class_">Process</span>.<span class="hljs-title function_">findModuleByName</span>(<span class="hljs-string">&quot;libil2cpp.so&quot;</span>);<br>    <span class="hljs-comment">// OnTriggerEnter2D</span><br>    <span class="hljs-keyword">var</span> offset1 = <span class="hljs-number">0x5E2BCC</span>;<br>    <span class="hljs-keyword">var</span> addr1 = libil2cpp.<span class="hljs-property">base</span>.<span class="hljs-title function_">add</span>(offset1);<br>    <span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">0xE5</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xEA</span>]; <span class="hljs-comment">// B 0x5E2F68</span><br>    <span class="hljs-comment">// 修改内存保护</span><br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">protect</span>(addr1, <span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;rwx&#x27;</span>);<br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">writeByteArray</span>(addr1, arr1);<br>    <span class="hljs-comment">// OnCollisionEnter2D</span><br>    <span class="hljs-keyword">var</span> offset2 = <span class="hljs-number">0x5E30CC</span>;<br>    <span class="hljs-keyword">var</span> addr2 = libil2cpp.<span class="hljs-property">base</span>.<span class="hljs-title function_">add</span>(offset2);<br>    <span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">0x40</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xEA</span>]; <span class="hljs-comment">// B 0x5E31D4</span><br>    <span class="hljs-comment">// 修改内存保护</span><br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">protect</span>(addr2, <span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;rwx&#x27;</span>);<br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">writeByteArray</span>(addr2, arr2);<br>&#125;);<br></code></pre></td></tr></table></figure><p>其实就是对内存中<code>CompareTag</code>的分支进行修改，将BNE修改为B指令，需要注意的是地址需要用基地址+相对偏移的方式得到，修改前需要修改段保护权限</p></li><li><p>关闭无敌</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">var</span> libil2cpp = <span class="hljs-title class_">Process</span>.<span class="hljs-title function_">findModuleByName</span>(<span class="hljs-string">&quot;libil2cpp.so&quot;</span>);<br>    <span class="hljs-comment">// OnTriggerEnter2D</span><br>    <span class="hljs-keyword">var</span> offset1 = <span class="hljs-number">0x5E2BCC</span>;<br>    <span class="hljs-keyword">var</span> addr1 = libil2cpp.<span class="hljs-property">base</span>.<span class="hljs-title function_">add</span>(offset1);<br>    <span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">0xE5</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x1A</span>]; <span class="hljs-comment">// BNE 0x5E2F68</span><br>    <span class="hljs-comment">// 修改内存保护</span><br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">protect</span>(addr1, <span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;rwx&#x27;</span>);<br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">writeByteArray</span>(addr1, arr1);<br>    <span class="hljs-comment">// OnCollisionEnter2D</span><br>    <span class="hljs-keyword">var</span> offset2 = <span class="hljs-number">0x5E30CC</span>;<br>    <span class="hljs-keyword">var</span> addr2 = libil2cpp.<span class="hljs-property">base</span>.<span class="hljs-title function_">add</span>(offset2);<br>    <span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">0x18</span>, <span class="hljs-number">0xB0</span>, <span class="hljs-number">0x8D</span>, <span class="hljs-number">0xE2</span>]; <span class="hljs-comment">// ADD R11, SP, #0x18</span><br>    <span class="hljs-comment">// 修改内存保护</span><br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">protect</span>(addr2, <span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;rwx&#x27;</span>);<br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">writeByteArray</span>(addr2, arr2);<br>&#125;);<br></code></pre></td></tr></table></figure><p>将两条指令改回来</p></li><li><p>开启飞行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">var</span> libil2cpp = <span class="hljs-title class_">Process</span>.<span class="hljs-title function_">findModuleByName</span>(<span class="hljs-string">&quot;libil2cpp.so&quot;</span>);<br>    <span class="hljs-comment">// 在LateUpdate函数中有设置重力的部分, 将数值修改为0.125减轻重力的影响</span><br>    <span class="hljs-keyword">var</span> offset1 = <span class="hljs-number">0x5E289C</span>;<br>    <span class="hljs-keyword">var</span> addr1 = libil2cpp.<span class="hljs-property">base</span>.<span class="hljs-title function_">add</span>(offset1);<br>    <span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">0x3D</span>, <span class="hljs-number">0x14</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0xE3</span>]; <span class="hljs-comment">// MOV R1. #0x3D000000 0.03125</span><br>    <span class="hljs-comment">// 修改内存保护</span><br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">protect</span>(addr1, <span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;rwx&#x27;</span>);<br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">writeByteArray</span>(addr1, arr1);<br>    <span class="hljs-keyword">var</span> offset2 = <span class="hljs-number">0x5E2A38</span>; <br>    <span class="hljs-keyword">var</span> addr2 = libil2cpp.<span class="hljs-property">base</span>.<span class="hljs-title function_">add</span>(offset2);<br>    <span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">0x3D</span>, <span class="hljs-number">0x14</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0xE3</span>]; <span class="hljs-comment">// MOV R1. #0x3D000000 0.03125</span><br>    <span class="hljs-comment">// 修改内存保护</span><br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">protect</span>(addr1, <span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;rwx&#x27;</span>);<br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">writeByteArray</span>(addr1, arr1);<br>    <span class="hljs-comment">// 将tiltSmooth修改为maxTiltSmooth的分支patch掉</span><br>    <span class="hljs-keyword">var</span> offset3 = <span class="hljs-number">0x5E2A14</span>; <br>    <span class="hljs-keyword">var</span> addr3 = libil2cpp.<span class="hljs-property">base</span>.<span class="hljs-title function_">add</span>(offset3);<br>    <span class="hljs-keyword">var</span> arr3 = [<span class="hljs-number">0x0A</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xEA</span>]; <span class="hljs-comment">// B 0x5E2A44</span><br>    <span class="hljs-comment">// 修改内存保护</span><br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">protect</span>(addr3, <span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;rwx&#x27;</span>);<br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">writeByteArray</span>(addr3, arr3);<br>    <span class="hljs-comment">// 还需要将thrust推力减小</span><br>    <span class="hljs-comment">// 由于不能直接拿到PlayerController的实例,需要先hook Update, 获得实例之后才能继续修改</span><br>    <span class="hljs-keyword">var</span> pc_instance = <span class="hljs-variable constant_">NULL</span>;<br>    <span class="hljs-keyword">var</span> func_offset = <span class="hljs-number">0x5E23E4</span>; <span class="hljs-comment">// PlayerController__Update</span><br>    <span class="hljs-keyword">var</span> func_addr = libil2cpp.<span class="hljs-property">base</span>.<span class="hljs-title function_">add</span>(func_offset);<br>    <span class="hljs-comment">// 函数对象</span><br>    <span class="hljs-keyword">var</span> targetFunc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeFunction</span>(func_addr, <span class="hljs-string">&#x27;void&#x27;</span>, [<span class="hljs-string">&#x27;pointer&#x27;</span>]);<br>    <span class="hljs-comment">// hook</span><br>    <span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(targetFunc, &#123;<br>        <span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) &#123;<br>            <span class="hljs-comment">// send(args[0]);</span><br>            pc_instance = args[<span class="hljs-number">0</span>];<br>            <span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">detachAll</span>();<br>            <span class="hljs-title function_">send</span>(<span class="hljs-string">`PlayerController Instance: <span class="hljs-subst">$&#123;pc_instance&#125;</span>`</span>);<br>            <span class="hljs-keyword">var</span> thrust_ptr = pc_instance.<span class="hljs-title function_">add</span>(<span class="hljs-number">0xC</span>); <span class="hljs-comment">// 偏移0xC</span><br>            <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">writeFloat</span>(thrust_ptr, <span class="hljs-number">50</span>);<br>            <span class="hljs-keyword">var</span> thrust = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readFloat</span>(thrust_ptr);<br>            <span class="hljs-title function_">send</span>(thrust);<br>        &#125;<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>开启飞行稍微有点复杂，首先需要修改刚体的重力，由于很难通过地址去之间修改重力值，并且前面分析知道在Update中会持续修改重力，直接改内存不可行，所以选择Patch修改重力部分的代码，原来的代码中一处设置重力为2.0，一处为1.0，这里将其修改为0.03125，这个值16进制表示方便，至于为什么不设置为0，是为了放置小鸟飞出屏幕，这里将其改小实现缓降的效果；tiltSmooth会影响小鸟下落的速度（貌似是旋转速度，没仔细测试，顺便改了），把tiltSmooth修改为maxTiltSmooth的分支patch掉的分支Patch掉；另外还影响飞行效果的就是点击屏幕时小鸟往上飞，需要将向上飞的效果减弱，不然容易飞出屏幕，经过前面的分析可以知道点击屏幕后会给小鸟一个向上的力，这个力保存在<code>this-&gt;fields.thrust</code>中，想要找到这个值，需要首先知道<code>PlayerController</code>实例的位置，但是显然没法直接得到，所以需要使用其他的方式来获取实例的地址，因为<code>Update</code>方法在每帧都会调用，并且第一个参数就是<code>PlayerController</code>的实例，所以可以直接hook<code>Update</code>函数，读取第一个参数，得到所需的实例地址，再根据偏移，得到<code>this-&gt;fields.thrust</code>的指针，经过测试可以知道施加的向上的力大小默认为225，这里改为50，减小向上飞的效果</p></li><li><p>关闭飞行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">var</span> libil2cpp = <span class="hljs-title class_">Process</span>.<span class="hljs-title function_">findModuleByName</span>(<span class="hljs-string">&quot;libil2cpp.so&quot;</span>);<br>    <span class="hljs-comment">// 在LateUpdate函数中有设置重力的部分, 恢复其数值</span><br>    <span class="hljs-keyword">var</span> offset1 = <span class="hljs-number">0x5E289C</span>;<br>    <span class="hljs-keyword">var</span> addr1 = libil2cpp.<span class="hljs-property">base</span>.<span class="hljs-title function_">add</span>(offset1);<br>    <span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">0xFE</span>, <span class="hljs-number">0x15</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0xE3</span>]; <span class="hljs-comment">// MOV R1, #0x3F800000</span><br>    <span class="hljs-comment">// 修改内存保护</span><br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">protect</span>(addr1, <span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;rwx&#x27;</span>);<br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">writeByteArray</span>(addr1, arr1);<br>    <span class="hljs-keyword">var</span> offset2 = <span class="hljs-number">0x5E2A38</span>;<br>    <span class="hljs-keyword">var</span> addr2 = libil2cpp.<span class="hljs-property">base</span>.<span class="hljs-title function_">add</span>(offset2);<br>    <span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">0x01</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0xE3</span>]; <span class="hljs-comment">// MOV R1, #0x40000000</span><br>    <span class="hljs-comment">// 修改内存保护</span><br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">protect</span>(addr1, <span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;rwx&#x27;</span>);<br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">writeByteArray</span>(addr1, arr1);<br>    <span class="hljs-comment">// 将tiltSmooth修改为maxTiltSmooth的分支恢复</span><br>    <span class="hljs-keyword">var</span> offset3 = <span class="hljs-number">0x5E2A14</span>; <br>    <span class="hljs-keyword">var</span> addr3 = libil2cpp.<span class="hljs-property">base</span>.<span class="hljs-title function_">add</span>(offset3);<br>    <span class="hljs-keyword">var</span> arr3 = [<span class="hljs-number">0x0A</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x5A</span>]; <span class="hljs-comment">// BPL 0x5E2A44</span><br>    <span class="hljs-comment">// 修改内存保护</span><br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">protect</span>(addr3, <span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;rwx&#x27;</span>);<br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">writeByteArray</span>(addr3, arr3);<br>    <span class="hljs-comment">// 恢复thrust推力</span><br>    <span class="hljs-comment">// 由于不能直接拿到PlayerController的实例,需要先hook Update, 获得实例之后才能继续修改</span><br>    <span class="hljs-keyword">var</span> pc_instance = <span class="hljs-variable constant_">NULL</span>;<br>    <span class="hljs-keyword">var</span> func_offset = <span class="hljs-number">0x5E23E4</span>; <span class="hljs-comment">// PlayerController__Update</span><br>    <span class="hljs-keyword">var</span> func_addr = libil2cpp.<span class="hljs-property">base</span>.<span class="hljs-title function_">add</span>(func_offset);<br>    <span class="hljs-comment">// 函数对象</span><br>    <span class="hljs-keyword">var</span> targetFunc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeFunction</span>(func_addr, <span class="hljs-string">&#x27;void&#x27;</span>, [<span class="hljs-string">&#x27;pointer&#x27;</span>]);<br>    <span class="hljs-comment">// hook</span><br>    <span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">attach</span>(targetFunc, &#123;<br>        <span class="hljs-attr">onEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) &#123;<br>            <span class="hljs-comment">// send(args[0]);</span><br>            pc_instance = args[<span class="hljs-number">0</span>];<br>            <span class="hljs-title class_">Interceptor</span>.<span class="hljs-title function_">detachAll</span>();<br>            <span class="hljs-title function_">send</span>(<span class="hljs-string">`PlayerController Instance: <span class="hljs-subst">$&#123;pc_instance&#125;</span>`</span>);<br>            <span class="hljs-keyword">var</span> thrust_ptr = pc_instance.<span class="hljs-title function_">add</span>(<span class="hljs-number">0xC</span>); <span class="hljs-comment">// 偏移0xC</span><br>            <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">writeFloat</span>(thrust_ptr, <span class="hljs-number">225</span>);<br>            <span class="hljs-keyword">var</span> thrust = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readFloat</span>(thrust_ptr);<br>            <span class="hljs-title function_">send</span>(<span class="hljs-string">`thrust: <span class="hljs-subst">$&#123;thrust&#125;</span>`</span>);<br>        &#125;<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>开启飞行的逆过程</p></li><li><p>修改分数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Java</span>.<span class="hljs-title function_">perform</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">var</span> libil2cpp = <span class="hljs-title class_">Process</span>.<span class="hljs-title function_">findModuleByName</span>(<span class="hljs-string">&quot;libil2cpp.so&quot;</span>);<br>    <span class="hljs-comment">// 读取GameManager_TypeInfo</span><br>    <span class="hljs-keyword">var</span> gm_info_addr = libil2cpp.<span class="hljs-property">base</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">0x7690F0</span>);<br>    <span class="hljs-keyword">var</span> gm_info = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readPointer</span>(gm_info_addr);<br>    <span class="hljs-keyword">var</span> gm_static_filed_addr = gm_info.<span class="hljs-title function_">add</span>(<span class="hljs-number">0x5C</span>); <span class="hljs-comment">// 结构体偏移0x5C</span><br>    <span class="hljs-keyword">var</span> gm_static_filed = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readPointer</span>(gm_static_filed_addr);<br>    <span class="hljs-keyword">var</span> gm_instance = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readPointer</span>(gm_static_filed); <span class="hljs-comment">// 偏移0x00</span><br>    <span class="hljs-keyword">var</span> gm_score_ptr = gm_instance.<span class="hljs-title function_">add</span>(<span class="hljs-number">0x50</span>); <span class="hljs-comment">// 分数偏移0x50</span><br>    <span class="hljs-keyword">var</span> gm_score = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readS32</span>(gm_score_ptr);<br>    <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">writeS32</span>(gm_score_ptr, gm_score+<span class="hljs-number">100</span>); <span class="hljs-comment">// 加100分</span><br>    gm_score = <span class="hljs-title class_">Memory</span>.<span class="hljs-title function_">readS32</span>(gm_score_ptr); <span class="hljs-comment">// 修改分数</span><br>    <span class="hljs-title function_">send</span>(<span class="hljs-string">`game score: <span class="hljs-subst">$&#123;gm_score&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>改分和设置飞行类似，需要通过实例找偏移再找到要改的数据的位置，但是<code>GameManager</code>是个静态类，直接有导出的地址，经过几次偏移就能得到，修改内存就能改分，这里直接加100分，遗憾的一点是改完后不会自动刷新，需要游戏触发一次更新分数才会显示，本来是想用frida调用<code>UpdateScore</code>函数的，但是调用的时候一直出错，所有没能实现自动刷新的效果</p></li></ul><p>使用未修改的游戏安装包安装测试：</p><p><img src="assets/2023-10-29-00-52-11-1%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA.gif"></p>]]></content>
    
    
    <categories>
      
      <category>腾讯游戏客户端安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>外挂实现分析-PC端</title>
    <link href="/2023/11/12/TencentGameClient/%E5%A4%96%E6%8C%82%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90-PC%E7%AB%AF/"/>
    <url>/2023/11/12/TencentGameClient/%E5%A4%96%E6%8C%82%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90-PC%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/noxke/TencentGameClientOpenCourse">GitHub - noxke&#x2F;TencentGameClientOpenCourse: 腾讯游戏客户端公开课2023 腾讯菁英班</a></p><h3 id="游戏分析"><a href="#游戏分析" class="headerlink" title="游戏分析"></a>游戏分析</h3><p>使用工具如下:</p><blockquote><p><a href="https://github.com/dnSpy/dnSpy">dnSpy v6.1.8</a></p><p><a href="https://github.com/cheat-engine/cheat-engine">Cheat Engine 7.5</a></p><p><a href="https://github.com/BepInEx/BepInEx">BepInEx 5.4.22</a></p><p><a href="https://github.com/BepInEx/BepInEx.ConfigurationManager">BepInEx.ConfigurationManager v18.0.1</a></p><p><a href="https://github.com/sinai-dev/UnityExplorer">UnityExplorer 4.9.0</a></p><p><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/index.html">Unity 脚本 API</a></p></blockquote><p>游戏使用Unity Mono实现，主要游戏逻辑在<code>./FlappyBird_Data/Managed/Assembly-CSharp.dll</code>文件中，使用C#语言编写</p><p>使用dnSpy加载游戏的程序集文件<code>Assembly-CSharp.dll</code></p><img title="" src="assets/2023-10-27-14-42-36-image.png" alt="" data-align="center" width="288"><p>根据类名可以知道每个类的主要功能，与小鸟有关的功能实现在<code>BirdScripts</code>类中，有关于游戏控制的实现在<code>GameControllers</code>类和<code>GamePlayController</code>类中</p><p>首先分析<code>BirdScripts</code>类</p><p><code>BirdScripts</code>类派生自<code>MonoBehaviour</code>，其中的<code>Awake</code>方法在加载实例时调用</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (BirdScripts.instance == <span class="hljs-literal">null</span>)<br>    &#123;<br>        BirdScripts.instance = <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">this</span>.isAlive = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">this</span>.score = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">this</span>.flapButton = GameObject.FindGameObjectWithTag(<span class="hljs-string">&quot;FlapButton&quot;</span>).GetComponent&lt;Button&gt;();<br>    <span class="hljs-keyword">this</span>.flapButton.onClick.AddListener(<span class="hljs-built_in">delegate</span>()<br>    &#123;<br>        <span class="hljs-keyword">this</span>.flapTheBird();<br>    &#125;);<br>    <span class="hljs-keyword">this</span>.CameraX();<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法主要是对小鸟的初始化，设置小鸟存活状态为true，设置分数0，绑定按钮事件等</p><p><code>FixUpdate</code>用于物理计算，循环调用</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isAlive)<br>    &#123;<br>        Vector3 position = <span class="hljs-keyword">base</span>.transform.position;<br>        position.x += <span class="hljs-keyword">this</span>.forwardSpeed * Time.deltaTime;<br>        <span class="hljs-keyword">base</span>.transform.position = position;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.didFlap)<br>        &#123;<br>            <span class="hljs-keyword">this</span>.didFlap = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">this</span>.myRigidBody.velocity = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">0f</span>, <span class="hljs-keyword">this</span>.bounceSpeed);<br>            <span class="hljs-keyword">this</span>.audioSource.PlayOneShot(<span class="hljs-keyword">this</span>.flapClick);<br>            <span class="hljs-keyword">this</span>.anim.SetTrigger(<span class="hljs-string">&quot;Flap&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.myRigidBody.velocity.y &gt;= <span class="hljs-number">0f</span>)<br>        &#123;<br>            <span class="hljs-keyword">base</span>.transform.rotation = Quaternion.Euler(<span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">float</span> z = Mathf.Lerp(<span class="hljs-number">0f</span>, <span class="hljs-number">-70f</span>, -<span class="hljs-keyword">this</span>.myRigidBody.velocity.y / <span class="hljs-number">7f</span>);<br>            <span class="hljs-keyword">base</span>.transform.rotation = Quaternion.Euler(<span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, z);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要逻辑是移动小鸟坐标，执行flap操作后为小鸟设置y方向上的速度向量，播放音乐，播放动画，当y方向上速度向量为0时小鸟不旋转，当y方向上速度向量小于0时小鸟绕z轴旋转</p><p>另外两个重要方法分别是<code>OnCollisionEnter2D</code>而<code>OnTriggerEnter2D</code></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter2D</span>(<span class="hljs-params">Collision2D target</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (target.gameObject.tag == <span class="hljs-string">&quot;Pipe&quot;</span> || target.gameObject.tag == <span class="hljs-string">&quot;Ground&quot;</span> || target.gameObject.tag == <span class="hljs-string">&quot;Enemy&quot;</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isAlive)<br>        &#123;<br>            <span class="hljs-keyword">this</span>.isAlive = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">this</span>.anim.SetTrigger(<span class="hljs-string">&quot;BirdDied&quot;</span>);<br>            <span class="hljs-keyword">this</span>.audioSource.PlayOneShot(<span class="hljs-keyword">this</span>.diedClip);<br>            GamePlayController.instance.playerDiedShowScore(<span class="hljs-keyword">this</span>.score);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target.gameObject.tag == <span class="hljs-string">&quot;Flag&quot;</span> &amp;&amp; <span class="hljs-keyword">this</span>.isAlive)<br>    &#123;<br>        <span class="hljs-keyword">this</span>.isAlive = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">this</span>.audioSource.PlayOneShot(<span class="hljs-keyword">this</span>.cheerClip);<br>        GamePlayController.instance.finishGame();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当小鸟刚体碰撞时调用<code>OnCollisionEnter2D</code>方法，发生碰撞后，根据目标的标签判断游戏失败或游戏胜利</p><p>当碰撞的物体为管道<code>Pipe</code>、地面<code>Ground</code>或敌人<code>Enemy</code>时，设置小鸟死亡，播放音乐，勃发动画，显示死亡分数等；当碰撞物体为棋子<code>Flag</code>时，游戏胜利</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D target</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (target.tag == <span class="hljs-string">&quot;PipeHolder&quot;</span>)<br>    &#123;<br>        <span class="hljs-keyword">this</span>.audioSource.PlayOneShot(<span class="hljs-keyword">this</span>.pointClip);<br>        <span class="hljs-keyword">this</span>.score++;<br>        GamePlayController.instance.setScore(<span class="hljs-keyword">this</span>.score);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当小鸟进入附加到该对象的触发碰撞体时调用<code>OnTriggerEnter2D</code>方法，该方法判断小鸟是否进入管道间隙<code>PipeHolder</code>，进入到管道间隙时分数加一，更新排名显示的分数</p><p><code>instance</code>成员保存当前的小鸟实例</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BirdScripts instance;<br></code></pre></td></tr></table></figure><p><code>myRigidBody</code>成员保存当前小鸟的刚体物理组件</p><h3 id="游戏破解"><a href="#游戏破解" class="headerlink" title="游戏破解"></a>游戏破解</h3><ul><li><h4 id="修改和重新编译C-程序集实现"><a href="#修改和重新编译C-程序集实现" class="headerlink" title="修改和重新编译C#程序集实现"></a>修改和重新编译C#程序集实现</h4></li></ul><p>根据上述分析可以了解，<code>OnCollisionEnter2D</code>内实现小鸟的碰撞检测，删除该方法内触发小鸟死亡的分支，可实现无敌效果，<code>OnTriggerEnter2D</code>内实现分数计算，修改该方法，可实增加游戏分数的效果</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter2D</span>(<span class="hljs-params">Collision2D target</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (target.gameObject.tag == <span class="hljs-string">&quot;Flag&quot;</span> &amp;&amp; <span class="hljs-keyword">this</span>.isAlive)<br>    &#123;<br>        <span class="hljs-keyword">this</span>.isAlive = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">this</span>.audioSource.PlayOneShot(<span class="hljs-keyword">this</span>.cheerClip);<br>        GamePlayController.instance.finishGame();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D target</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (target.tag == <span class="hljs-string">&quot;PipeHolder&quot;</span>)<br>    &#123;<br>        <span class="hljs-keyword">this</span>.audioSource.PlayOneShot(<span class="hljs-keyword">this</span>.pointClip);<br>        <span class="hljs-keyword">this</span>.score += <span class="hljs-number">233</span>;<br>        GamePlayController.instance.setScore(<span class="hljs-keyword">this</span>.score);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>dnSpy修改方法并重新编译，替换原<code>Assembly-CSharp.dll</code>程序集，运行游戏测试</p><p><img src="assets/2023-10-27-15-15-10-image.png"></p><p>无敌功能和分数修改功能已实现</p><ul><li><h4 id="Cheat-Engine动态修改实现"><a href="#Cheat-Engine动态修改实现" class="headerlink" title="Cheat Engine动态修改实现"></a>Cheat Engine动态修改实现</h4></li></ul><p>开始游戏，暂停后使用CE打开游戏进程，选择<code>Mono-&gt;.Net Info</code>查看进程加载的模块信息，选择<code>Assembly-CSharp-&gt;BirdScript</code>模块</p><p><img src="assets/2023-10-27-15-23-26-image.png"></p><p><code>instance</code>为当前的小鸟实例，可以查看当前小鸟实例的成员属性和方法</p><p>可以查看和修改<code>OnCollisionEnter2D</code>和<code>OnTriggerEnter2D</code>的JIT代码</p><p>先分析<code>OnCollisionEnter2D</code>的JIT代码，主要分析跳转指令</p><p><img src="assets/2023-10-27-15-38-32-image.png"></p><p><img src="assets/2023-10-27-15-39-02-image.png"></p><p><img src="assets/2023-10-27-15-39-31-image.png"></p><p><img src="assets/2023-10-27-15-39-57-image.png"></p><p>根据之前的源代码可以轻松分析处这部分调整是判断小鸟是否碰撞到会死亡的物体，当或语句中有任意一条成立时，跳转到<code>0x121</code>行执行，如果或语句中3条判断都不成立，跳转到<code>0x1a4</code>行，进入到<code>0x121</code>行后，会判断小鸟的<code>isAlive</code>是否为<code>false</code>，为<code>false</code>跳转到<code>0x255</code>行退出调用，否则执行后续代码</p><p>另一个判断是否碰撞到棋子的分支类似</p><p>将第<code>0x127</code>行分支修改为强制跳转，不执行后续代码，即可绕过小鸟死亡代码的执行</p><p><img src="assets/2023-10-27-15-47-50-image.png"></p><p>回到游戏进行测试</p><p><img src="assets/2023-10-27-15-48-36-image.png"></p><p>小鸟的无敌效果已经实现</p><p>查看<code>OnTriggerEnter2D</code>方法的JIT代码</p><p><img src="assets/2023-10-27-15-50-18-image.png"></p><p><img src="assets/2023-10-27-15-50-41-image.png"></p><p>很明显，<code>0x4a</code>行判断是否进入到管道间隙，中间的代码为修改分数的部分</p><p><img src="assets/2023-10-27-15-52-41-image.png"></p><p><img src="assets/2023-10-27-15-53-08-image.png"></p><p>将<code>0x77</code>行inc指令修改为dec指令，使小鸟进入管道间隙分数减1</p><p>回到游戏进行测试</p><p><img src="assets/2023-10-27-15-54-40-image.png"></p><p>分数减为复数</p><p>也可以通过修改小鸟实例下的<code>score</code>实现分数修改</p><p><img src="assets/2023-10-27-15-59-08-image.png"></p><p><img src="assets/2023-10-27-15-59-27-image.png"></p><ul><li><h4 id="UnityExplorer动态分析游戏"><a href="#UnityExplorer动态分析游戏" class="headerlink" title="UnityExplorer动态分析游戏"></a>UnityExplorer动态分析游戏</h4></li></ul><blockquote><p>UnityExplorer可以使用BepInEx、MelonLoader和Standalone三种加载方式加载，测试发现BepInEx的效率要高一点，比MelonLoader加载要流畅很多，而且BepInEx的文档更完善，方便插件的开发，因此后续使用BepInEx加载UnityExplorer进行分析，同时安装ConfigurationManager便于插件的管理和配置</p></blockquote><p>BepInEx和UnityExplorer的安装在仓库Readme中都很详细，注意版本即可，此处选择的是BepInEx 5.4.22版本，安装后启用<code>Logging.Console</code>设置，方便查看日志信息</p><p><img src="assets/2023-10-27-16-15-38-image.png"></p><p>在UnityExplorer中能看到小鸟的位置信息和加载的组件信息，主要关注<code>RigidBody2D</code>组件和<code>CircleCollider2D</code>组件</p><p><code>RigidBody2D</code>组件是小鸟的刚体组件信息，<code>gravityScale</code>变量是刚体受重力的影响程度，将其修改为0可实现不受重力影响，实现漂浮效果，但需要同时将速度向量<code>velocity</code>变量修改为0，避免小鸟持续向上或向下飞行，还需要将小鸟的<code>bounceSpeed</code>修改为0，避免手贱点到屏幕让小鸟增加y方向的速度</p><p><code>CircleCollider2D</code>是小鸟的碰撞组件信息，将<code>enable</code>修改为false可关闭小鸟的碰撞</p><p><img src="assets/2023-10-27-16-36-00-image.png"></p><p>修改后就实现了小鸟的悬浮飞行和穿墙效果，但是由于禁用了碰撞组件，因此不会检测与管道间隙的碰撞，分数不会增加，接触棋子也不会结束游戏，想要保存穿墙效果的同时能够增加分数，可以将所有管道、敌人的碰撞组件禁用</p><ul><li><h4 id="BepInEx实现游戏插件"><a href="#BepInEx实现游戏插件" class="headerlink" title="BepInEx实现游戏插件"></a>BepInEx实现游戏插件</h4></li></ul><p>上述的修改方法中，除了修改程序集重新编译，另外两种均为手动修改，而且重新加载游戏后修改会失效，并且实现的功能有限，因此后续选择编写程序集的方法进行游戏破解</p><p>课堂视频中已经展示了使用<code>SharpMonoInjector</code>工具注入程序集实现破解功能，但是仍然需要手动注入，<del>不够优雅</del>，因此这里选择用BepInEx插件的形式实现</p><p>插件开发文档：</p><blockquote><p><a href="https://docs.bepinex.dev/articles/dev_guide/plugin_tutorial/index.html">https://docs.bepinex.dev/articles/dev_guide/plugin_tutorial/index.html</a></p><p><a href="https://mod.3dmgame.com/read/3">从0开始教你使用BepInEx为unity游戏制作插件Mod - 3DM Mod站</a></p></blockquote><p><del>没写过C#代码，代码可能不够规范</del></p><p><code>Plugin.cs</code>是插件的入口类代码，<code>Plugin</code>类派生自<code>BaseUnityPlugin</code></p><p><code>GlobalVariables.cs</code>是代码使用的全局变量类，主要保存插件的配置信息已经从游戏内获取的对象信息</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GlobalVariables</span><br>&#123;<br>    <span class="hljs-comment">// 全局变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BirdScripts birdInstances; <span class="hljs-comment">// 当前小鸟实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Rigidbody2D birdRigidbody2D; <span class="hljs-comment">// 小鸟的Rigidbody2D组件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Collider2D birdCollider2D; <span class="hljs-comment">// 小鸟的Collider2D组件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject[] pipes; <span class="hljs-comment">// 管道</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject[] pipeHolders; <span class="hljs-comment">// 管道间隙</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject[] enemies; <span class="hljs-comment">// 敌人</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject[] flags; <span class="hljs-comment">// flag</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigEntry&lt;<span class="hljs-built_in">bool</span>&gt; invincible; <span class="hljs-comment">// 无敌</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigEntry&lt;<span class="hljs-built_in">bool</span>&gt; collision; <span class="hljs-comment">// 碰撞</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigEntry&lt;<span class="hljs-built_in">bool</span>&gt; fly; <span class="hljs-comment">// 飞行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigEntry&lt;<span class="hljs-built_in">float</span>&gt; speed; <span class="hljs-comment">// 游戏速度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigEntry&lt;<span class="hljs-built_in">int</span>&gt; score; <span class="hljs-comment">// 分数</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Cheat.cs</code>是插件作弊功能的核心实现</p><p>下面依次进行分析</p><p>与<code>MonoBehaviour</code>类似，<code>BaseUnityPlugin</code>中的<code>Awake</code>方法在类实例加载时执行，该方法内用于绑定插件的设置，便于在ConfigurationManager插件中图形化地修改参数配置</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>&#123;<br>    <span class="hljs-comment">// 插件启用时调用</span><br>    Logger.LogInfo(<span class="hljs-string">$&quot;Plugin <span class="hljs-subst">&#123;PluginInfo.PLUGIN_NAME&#125;</span> is loaded!&quot;</span>);<br>    <span class="hljs-comment">// 创建配置项</span><br>    GlobalVariables.invincible = Config.Bind(<span class="hljs-string">&quot;Config&quot;</span>, <span class="hljs-string">&quot;invincible&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;碰撞无敌&quot;</span>);<br>    GlobalVariables.invincible.Value = <span class="hljs-literal">false</span>;<br>    GlobalVariables.collision = Config.Bind(<span class="hljs-string">&quot;Config&quot;</span>, <span class="hljs-string">&quot;collision&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;开启碰撞&quot;</span>);<br>    GlobalVariables.collision.Value = <span class="hljs-literal">true</span>;<br>    GlobalVariables.fly = Config.Bind(<span class="hljs-string">&quot;Config&quot;</span>, <span class="hljs-string">&quot;fly&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;开启飞行&quot;</span>);<br>    GlobalVariables.fly.Value = <span class="hljs-literal">false</span>;<br>    GlobalVariables.score = Config.Bind(<span class="hljs-string">&quot;Config&quot;</span>, <span class="hljs-string">&quot;score&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;游戏分数&quot;</span>);<br>    GlobalVariables.score.Value = <span class="hljs-number">0</span>;<br>    GlobalVariables.speed = Config.Bind(<span class="hljs-string">&quot;Config&quot;</span>, <span class="hljs-string">&quot;speed&quot;</span>, <span class="hljs-number">3f</span>, <span class="hljs-string">&quot;移动速度&quot;</span>);<br>    GlobalVariables.speed.Value = <span class="hljs-number">3f</span>;<br>    <span class="hljs-comment">// 关闭碰撞的回调函数</span><br>    GlobalVariables.collision.SettingChanged += (sender, args) =&gt; Cheat.instance.SetCollision(GlobalVariables.collision.Value);<br>    <span class="hljs-comment">// 飞行回调函数</span><br>    GlobalVariables.fly.SettingChanged += (sender, args) =&gt; Cheat.instance.SetFly(GlobalVariables.fly.Value);<br>    <span class="hljs-comment">// 修改分数的回调函数</span><br>    GlobalVariables.score.SettingChanged += (sender, args) =&gt; Cheat.instance.SetScore(GlobalVariables.score.Value);<br>    <span class="hljs-comment">// 修改游戏速度的回调函数</span><br>    GlobalVariables.speed.SettingChanged += (sender, args) =&gt; Cheat.instance.SetSpeed(GlobalVariables.speed.Value);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Start</code>方法在所有插件加载后调用，此处用于实例化<code>Cheat</code>类对象</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>&#123;<br>    <span class="hljs-comment">// 所有插件全部加载后调用</span><br>    Logger.LogInfo(<span class="hljs-string">$&quot;Plugin <span class="hljs-subst">&#123;PluginInfo.PLUGIN_NAME&#125;</span> is started!&quot;</span>);<br>    Cheat.instance = <span class="hljs-keyword">new</span> Cheat();<br>    Cheat.instance.Start();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Update</code>方法会在游戏的每一帧调用，循环执行，此处用于调用<code>Cheat</code>类的<code>Update</code>方法</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>    <span class="hljs-comment">// 持续执行</span><br>    <span class="hljs-comment">// Debug.Log($&quot;Plugin &#123;PluginInfo.PLUGIN_NAME&#125; is Update!&quot;);</span><br>    Cheat.instance.Update();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>OnGUI</code>方法用于在屏幕上显示标签，并显示当前开启的作弊功能</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>()</span><br>&#123;<br>    <span class="hljs-comment">// 在游戏界面上显示标签</span><br>    GUI.skin.label.fontSize = <span class="hljs-number">18</span>;<br>    GUI.skin.label.normal.textColor = Color.blue;<br>    <span class="hljs-built_in">string</span> labelText = <span class="hljs-string">&quot;FlappyBird Cheat Plugin\n&quot;</span>;<br>    labelText += <span class="hljs-string">&quot;written by noxke\n&quot;</span>;<br>    labelText += <span class="hljs-string">&quot;[F1] : config and more feature\n&quot;</span>;<br>    labelText += <span class="hljs-string">&quot;[ESC] : pause\n&quot;</span>;<br>    labelText += <span class="hljs-string">$&quot;[1/2] invincible [<span class="hljs-subst">&#123;GlobalVariables.invincible.Value&#125;</span>]\n&quot;</span>;<br>    labelText += <span class="hljs-string">$&quot;[3/4] : collision [<span class="hljs-subst">&#123;GlobalVariables.collision.Value&#125;</span>]\n&quot;</span>;<br>    labelText += <span class="hljs-string">$&quot;[5/6] : fly [<span class="hljs-subst">&#123;GlobalVariables.fly.Value&#125;</span>]\n&quot;</span>;<br>    labelText += <span class="hljs-string">&quot;[9] : add score\n&quot;</span>;<br>    labelText += <span class="hljs-string">&quot;[up/down/left/right] : move\n&quot;</span>;<br>    labelText += <span class="hljs-string">&quot;[0] : finish game\n&quot;</span>;<br>    labelText += <span class="hljs-string">$&quot;speed [<span class="hljs-subst">&#123;GlobalVariables.speed.Value&#125;</span>]&quot;</span>;<br>    GUI.Label(<span class="hljs-keyword">new</span> Rect(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">400</span>, <span class="hljs-number">300</span>), labelText);<br>&#125;<br></code></pre></td></tr></table></figure><img title="" src="assets/2023-10-27-17-01-16-image.png" alt="" width="190"><p><code>Cheat</code>类为作弊功能的实现</p><p>类加载时调用<code>Start</code>方法，进而调用<code>SetPatch</code>方法</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetPatch</span>()</span><br><span class="hljs-function"><span class="hljs-comment">// 设置勾取函数</span></span><br>&#123;<br>    <span class="hljs-comment">// patch OnCollisionEnter2D方法</span><br>    Harmony harmony1 = <span class="hljs-keyword">new</span> Harmony(<span class="hljs-string">&quot;com.noxke.patch1&quot;</span>);<br>    MethodInfo onCollisionEnter2D = AccessTools.Method(<span class="hljs-keyword">typeof</span>(BirdScripts), <span class="hljs-string">&quot;OnCollisionEnter2D&quot;</span>);<br>    harmony1.Patch(onCollisionEnter2D, prefix: <span class="hljs-keyword">new</span> HarmonyMethod(<span class="hljs-keyword">typeof</span>(Cheat).GetMethod(<span class="hljs-string">&quot;PrefixOnCollisionEnter2D&quot;</span>)));<br>    Debug.Log(<span class="hljs-string">&quot;Patch OnCollisionEnter2D&quot;</span>);<br><br>    <span class="hljs-comment">// patch flapTheBird方法</span><br>    Harmony harmony2 = <span class="hljs-keyword">new</span> Harmony(<span class="hljs-string">&quot;com.noxke.patch2&quot;</span>);<br>    MethodInfo flapTheBird = AccessTools.Method(<span class="hljs-keyword">typeof</span>(BirdScripts), <span class="hljs-string">&quot;flapTheBird&quot;</span>);<br>    harmony2.Patch(flapTheBird, prefix: <span class="hljs-keyword">new</span> HarmonyMethod(<span class="hljs-keyword">typeof</span>(Cheat).GetMethod(<span class="hljs-string">&quot;PrefixFlapTheBird&quot;</span>)));<br>    Debug.Log(<span class="hljs-string">&quot;Patch flapTheBird&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SetPatch</code>方法内利用<code>Harmony</code>提供的<code>Patch</code>功能勾取<code>BirdScripts</code>类的<code>OnCollisionEnter2D</code>方法和<code>flapTheBird</code>方法，由于<code>OnCollisionEnter2D</code>是<code>private</code>方法，需要使用反射的方法设置Patch</p><p>在<code>OnCollisionEnter2D</code>方法被调用前执行<code>Cheat</code>类的<code>PrefixOnCollisionEnter2D</code>方法，判断发生碰撞的是否为管道、大地或者敌人，如果是，则跳过屏蔽<code>OnCollisionEnter2D</code>方法的执行，屏蔽小鸟的死亡，如果为其他情况，即碰到棋子，则会执行原方法，触发游戏胜利</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">PrefixOnCollisionEnter2D</span>(<span class="hljs-params">BirdScripts __instance, Collision2D target</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 在发生碰撞前拦截</span><br>    <span class="hljs-keyword">if</span> (GlobalVariables.invincible.Value != <span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 碰撞到flag的时候胜利，不做拦截</span><br>    <span class="hljs-keyword">if</span> (target.gameObject.tag == <span class="hljs-string">&quot;Pipe&quot;</span> || target.gameObject.tag == <span class="hljs-string">&quot;Ground&quot;</span> || target.gameObject.tag == <span class="hljs-string">&quot;Enemy&quot;</span>)<br>    &#123;<br>        Debug.Log(<span class="hljs-string">$&quot;Collision <span class="hljs-subst">&#123;target.gameObject.tag&#125;</span>&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>flapTheBird</code>方法调用前，即屏幕被点击触发小鸟向上飞之前，执行<code>Cheat</code>类的<code>PrefixFlapTheBird</code>方法，主要用来在飞行状态中屏蔽flap操作，避免小鸟获得向上的向量速度飞出屏幕<del>为什么不之间修改bounceSpeed???</del></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">PrefixFlapTheBird</span>(<span class="hljs-params">BirdScripts __instance</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 在flap前调用</span><br>    <span class="hljs-comment">// 避免飞行时flap然后无法减速</span><br>    Debug.Log(<span class="hljs-string">&quot;Patch flapTheBird&quot;</span>);<br>    <span class="hljs-keyword">if</span> (GlobalVariables.fly.Value == <span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Update</code>方法循环调用，用于设置按键绑定，从游戏内获取对象，已经同步游戏分数到配置</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>    <span class="hljs-comment">// 循环调用</span><br>    KeyBound(); <span class="hljs-comment">// 按键检测</span><br>    GetObjects(); <span class="hljs-comment">// 获取游戏对象</span><br>    <span class="hljs-keyword">if</span> (GlobalVariables.birdInstances != <span class="hljs-literal">null</span>)<br>    &#123;<br>        GlobalVariables.score.Value = GlobalVariables.birdInstances.score; <span class="hljs-comment">// 同步分数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>KeyBound</code>方法用于监听按键操作，调用<code>Cheat</code>中的功能</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">KeyBound</span>()</span><br>&#123;<br>    <span class="hljs-comment">// 按键绑定</span><br>    <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.Escape))<br>    &#123;<br>        <span class="hljs-comment">// ESC暂停 鼠标太难点了</span><br>        <span class="hljs-keyword">if</span> (GamePlayController.instance != <span class="hljs-literal">null</span>)<br>        &#123;<br>            Debug.Log(<span class="hljs-string">&quot;key ESC down, pause&quot;</span>);<br>            GamePlayController.instance.pauseGame();<br><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>GetObjects</code>方法从游戏中获取小鸟的实例，获取小鸟的组件信息，获取游戏中的管道对象、管道间隙对象等</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetObjects</span>()</span><br>&#123;<br>    <span class="hljs-comment">// 获取游戏内对象和实例</span><br>    GlobalVariables.birdInstances = BirdScripts.instance; <span class="hljs-comment">// 获取当前小鸟实例</span><br>    <span class="hljs-keyword">if</span> (GlobalVariables.birdInstances != <span class="hljs-literal">null</span>)<br>    &#123;<br>        <span class="hljs-comment">// 获取小鸟的组件</span><br>        GlobalVariables.birdCollider2D = GlobalVariables.birdInstances.GetComponent&lt;Collider2D&gt;();<br>        GlobalVariables.birdRigidbody2D = GlobalVariables.birdInstances.GetComponent&lt;Rigidbody2D&gt;();<br>    &#125;<br>    GlobalVariables.pipes = GameObject.FindGameObjectsWithTag(<span class="hljs-string">&quot;Pipe&quot;</span>);  <span class="hljs-comment">// 管道</span><br>    GlobalVariables.pipeHolders = GameObject.FindGameObjectsWithTag(<span class="hljs-string">&quot;PipeHolder&quot;</span>); <span class="hljs-comment">// 获取当前的管道间隙</span><br>    GlobalVariables.enemies = GameObject.FindGameObjectsWithTag(<span class="hljs-string">&quot;Enemy&quot;</span>);  <span class="hljs-comment">// 敌人</span><br>    GlobalVariables.flags = GameObject.FindGameObjectsWithTag(<span class="hljs-string">&quot;Flag&quot;</span>);  <span class="hljs-comment">// flag</span><br>&#125;<br></code></pre></td></tr></table></figure><p>小鸟的穿墙功能，即屏蔽碰撞的功能在<code>SetCollision</code>方法中实现</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetCollision</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> <span class="hljs-keyword">value</span></span>)</span><br>&#123;<br>    <span class="hljs-comment">// 设置管道和敌人的碰撞</span><br>    GlobalVariables.collision.Value = <span class="hljs-keyword">value</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; GlobalVariables.pipes.Length; i++)<br>    &#123;<br>        BoxCollider2D pipeBoxCollider2D = GlobalVariables.pipes[i].GetComponent&lt;BoxCollider2D&gt;();<br>        <span class="hljs-keyword">if</span> (pipeBoxCollider2D != <span class="hljs-literal">null</span>)<br>        &#123;<br>            pipeBoxCollider2D.enabled = <span class="hljs-keyword">value</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; GlobalVariables.enemies.Length; i++)<br>    &#123;<br>        BoxCollider2D enemyBoxCollider2D = GlobalVariables.enemies[i].GetComponent&lt;BoxCollider2D&gt;();<br>        <span class="hljs-keyword">if</span> (enemyBoxCollider2D == <span class="hljs-literal">null</span>)<br>        &#123;<br>            Collider2D enemyCollider2D = GlobalVariables.enemies[i].GetComponent&lt;Collider2D&gt;();<br>            <span class="hljs-keyword">if</span> (enemyCollider2D != <span class="hljs-literal">null</span>)<br>            &#123;<br>                enemyCollider2D.enabled = <span class="hljs-keyword">value</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            enemyBoxCollider2D.enabled = <span class="hljs-keyword">value</span>;<br>        &#125;<br>    &#125;<br>    Debug.Log(<span class="hljs-string">$&quot;collision : <span class="hljs-subst">&#123;<span class="hljs-keyword">value</span>&#125;</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里实现的方法不是禁用小鸟的碰撞组件，因为会影响游戏得分，使用的是禁用游戏中管道、敌人的碰撞组件</p><p><code>SetFly</code>方法开启悬浮飞行，设置小鸟的重力影响为0，将速度向量设为0</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetFly</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> <span class="hljs-keyword">value</span></span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">// 关闭重力影响</span><br>        GlobalVariables.birdRigidbody2D.gravityScale = <span class="hljs-number">0f</span>;<br>        <span class="hljs-comment">// 速度向量设为0</span><br>        GlobalVariables.birdRigidbody2D.velocity = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 恢复重力影响</span><br>        GlobalVariables.birdRigidbody2D.gravityScale = <span class="hljs-number">1f</span>;<br>    &#125;<br>    Debug.Log(<span class="hljs-string">$&quot;fly : <span class="hljs-subst">&#123;<span class="hljs-keyword">value</span>&#125;</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SetSocre</code>修改游戏分数，并刷新分数显示</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetScore</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>&#123;<br>    <span class="hljs-comment">// 设置游戏分数</span><br>    GlobalVariables.birdInstances.score = <span class="hljs-keyword">value</span>;<br>    GamePlayController.instance.setScore(<span class="hljs-keyword">value</span>);<br>    Debug.Log(<span class="hljs-string">$&quot;set score  <span class="hljs-subst">&#123;<span class="hljs-keyword">value</span>&#125;</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SetSpeed</code>设置x方向移动速度，由于<code>forwardSpeed</code>是<code>BirdScripts</code>的私有成员，不能能够小鸟的实例来直接修改，需要使用反射机制修改</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetSpeed</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> <span class="hljs-keyword">value</span></span>)</span><br>&#123;<br>    <span class="hljs-comment">// 设置x轴速度</span><br>    GlobalVariables.speed.Value = <span class="hljs-keyword">value</span>;<br>    <span class="hljs-comment">// 私有成员需要使用反射修改</span><br>    FieldInfo privateField = <span class="hljs-keyword">typeof</span>(BirdScripts).GetField(<span class="hljs-string">&quot;forwardSpeed&quot;</span>, BindingFlags.NonPublic | BindingFlags.Instance);<br>    <span class="hljs-keyword">if</span> (privateField != <span class="hljs-literal">null</span>)<br>    &#123;<br>        privateField.SetValue(GlobalVariables.birdInstances, <span class="hljs-keyword">value</span>);<br>        Debug.Log(<span class="hljs-string">$&quot;forward speed : <span class="hljs-subst">&#123;<span class="hljs-keyword">value</span>&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>BirdMove</code>将小鸟向指定方向移动</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BirdMove</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> x, <span class="hljs-built_in">float</span> y</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (GlobalVariables.birdInstances != <span class="hljs-literal">null</span>)<br>    &#123;<br>        Vector3 basePosition = GlobalVariables.birdInstances.transform.position;<br>        basePosition.x += x;<br>        basePosition.y += y;<br>        GlobalVariables.birdInstances.transform.position = basePosition;<br>        Debug.Log(<span class="hljs-string">$&quot;move bird x : <span class="hljs-subst">&#123;x&#125;</span>, y : <span class="hljs-subst">&#123;y&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FinishGame</code>触发游戏胜利，播放胜利音效</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FinishGame</span>()</span><br>&#123;<br>    <span class="hljs-comment">// 游戏胜利</span><br>    <span class="hljs-keyword">if</span> (GlobalVariables.birdInstances != <span class="hljs-literal">null</span>)<br>    &#123;<br>        GlobalVariables.birdInstances.isAlive = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 需要利用反射调用私有方法和获取私有变量</span><br>        FieldInfo cheerClipFiled = <span class="hljs-keyword">typeof</span>(BirdScripts).GetField(<span class="hljs-string">&quot;cheerClip&quot;</span>, BindingFlags.NonPublic | BindingFlags.Instance);<br>        AudioSource audioSource = GlobalVariables.birdInstances.GetComponent&lt;AudioSource&gt;();<br>        audioSource.PlayOneShot((AudioClip)cheerClipFiled.GetValue(GlobalVariables.birdInstances));<br>        GamePlayController.instance.finishGame();<br>        Debug.Log(<span class="hljs-string">&quot;finish game!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译插件得到<code>CheatPlugin.dll</code>，复制到plugins插件文件下启动游戏</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> C:\workspace\腾讯菁英班\外挂实现分析<span class="hljs-literal">-PC</span>端\CheatPlugin&gt; dotnet build; <span class="hljs-built_in">cp</span> .\bin\Debug\net35\CheatPlugin.dll ..\FlappyBird_BepInEx\BepInEx\plugins\<br>MSBuild version <span class="hljs-number">17.3</span>.<span class="hljs-number">2</span>+<span class="hljs-number">561848881</span> <span class="hljs-keyword">for</span> .NET<br>  正在确定要还原的项目…<br>  所有项目均是最新的，无法还原。<br>  CheatPlugin -&gt; C:\workspace\腾讯菁英班\外挂实现分析<span class="hljs-literal">-PC</span>端\CheatPlugin\bin\Debug\net35\CheatPlugin.dll<br><br>已成功生成。<br>    <span class="hljs-number">0</span> 个警告<br>    <span class="hljs-number">0</span> 个错误<br><br>已用时间 <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00.69</span><br></code></pre></td></tr></table></figure><p>根据GUI提示，F1打开控制菜单，ESC暂停游戏，1&#x2F;2切换无敌，3&#x2F;4切换碰撞，5&#x2F;6切换飞行，9增加分数，0结束游戏，上下左右控制小鸟移动</p><p><img src="assets/2023-10-27-19-37-06-%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA.gif"></p>]]></content>
    
    
    <categories>
      
      <category>腾讯游戏客户端安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PC端VMP壳逆向分析</title>
    <link href="/2023/10/17/TencentGameClient/PC%E7%AB%AFVMP%E5%A3%B3%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    <url>/2023/10/17/TencentGameClient/PC%E7%AB%AFVMP%E5%A3%B3%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/noxke/TencentGameClientOpenCourse">GitHub - noxke&#x2F;TencentGameClientOpenCourse: 腾讯游戏客户端公开课2023 腾讯菁英班</a></p><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>运行<code>crackme2.exe</code>文件，熟悉的检测到虚拟机弹窗</p><img src="2023-10-17-00-11-03-image.png" title="" alt="" width="161"><p>大概率vmp加壳，使用<code>exeinfo</code>工具验证</p><img src="2023-10-17-00-11-58-image.png" title="" alt="" width="434"><p>确认是vmp加壳，<del>关闭环境，打开移动端题目分析</del></p><p>使用ida64打开程序确认加壳的部分</p><img src="2023-10-17-00-16-33-image.png" title="" alt="" width="583"><p>程序入口push call，典型的vmp特征，程序入口处加壳，无法静态定位到程序入口点，暂时不能确定是否对整个程序加壳，静态分析难度较大</p><h3 id="动态调试分析"><a href="#动态调试分析" class="headerlink" title="动态调试分析"></a>动态调试分析</h3><p>由于有vmp壳的存在，程序有虚拟机检测和调试器检测，使用ida绕过调试不方便，应此使用<a href="https://github.com/x64dbg/x64dbg">x64dbg</a>进行调试分析</p><p>反调试屏蔽插件<code>ScyllaHide</code>设置如下</p><img title="" src="2023-10-17-00-24-44-image.png" alt="" width="461"><p>调试器运行程序，第一次会在程序入口点断下</p><p><img src="2023-10-17-00-29-45-image.png"></p><p>此处为vmp入口点，继续运行程序</p><p><img src="2023-10-17-00-31-19-image.png"></p><p>程序会在上图三处<code>nop</code>指令处断下，直接继续运行，如果反调试屏蔽正常，程序将进入运行状态</p><p><img src="2023-10-17-00-32-47-image.png"></p><p>等待输入状态中，随意输入并回车后（两次回车），程序继续运行，几秒钟后程序关闭，和没有调试器运行时状态一致，因此已经绕过程序的反调试</p><p>由于不确定程序的逻辑部分是否加壳，通过API调用栈回溯的方式找到API调用代码</p><p>对可能的输入输出API下断点</p><ul><li><p>kernel32.ReadConsoleW</p></li><li><p>kernel32.ReadFile</p></li><li><p>kernel32.WriteConsoleW</p></li><li><p>kernel32.WriteConsoleA</p></li><li><p>kernel32.WriteFile</p></li></ul><p><img src="2023-10-17-00-38-15-image.png"></p><p>重新调试运行程序，跳过几个检测断点后，进程在<code>kernel32.WriteFile</code>断下，查看参数寄存器</p><img src="2023-10-17-00-40-35-image.png" title="" alt="" width="349"><p>rcx为文件句柄，rdx为输出缓冲区，r8为输出字节长度，其他参数此处忽略</p><p>输出字符串为<code>请输入flag:\r\n\r</code>，正好为程序的输出提示，因此可以确认程序的输入输出分别使用<code>ReadFile</code>和<code>WriteFile</code>实现，关闭其他断点</p><p>查看调用堆栈</p><p><img src="2023-10-17-00-46-06-image.png"></p><p>堆栈调用过多，逐层返回分析</p><img src="2023-10-17-00-49-21-image.png" title="" alt="" width="508"><p>当进程返回到<code>0x140298DF8</code>地址处时，继续Ctrl+F9后程序在<code>ReadFile</code>断下，因此程序的输出逻辑应该在<code>0x140298DF8</code>附近</p><img src="2023-10-17-00-50-27-image.png" title="" alt="" width="629"><p>断下位置应该是程序的输入位置，与输出时的回溯相同，查看调用堆栈，逐层返回分析</p><p>返回到如下位置，与上述的输出提示字符串位置接近</p><p><img src="2023-10-17-00-56-33-image.png"></p><p>查看进程堆栈</p><img src="2023-10-17-00-59-12-image.png" title="" alt="" width="511"><p>输入的字符串地址储存在堆栈中，还观察到有格式化字符串<code>&quot;%s&quot;</code>存在，因此猜测次数为格式化输入函数调用</p><p>因此可以确认<code>0x140298E12</code>为输出提示字符串位置，<code>0x140298E12</code>为输入字符串位置，此时能够确定程序的逻辑部分未被vmp加壳，可以继续后续的动态调试分析</p><p>回溯堆栈确定程序的入口点</p><p><img src="2023-10-17-01-01-50-image.png"></p><p>观察到用户层只有两层调用，因此当前层的上一层为程序的入口点位置</p><p><img src="2023-10-17-01-02-53-image.png"></p><p>此时可确认程序的入口点OEP为<code>0x140001510</code>，下断点，主函数为<code>0x1400010C0</code>，输出提示字符串位置为<code>0x140298DF3</code>，输入字符传位置为<code>0x140298E0D</code>，对这几个地址下断点，重新调试运行程序，跳过检测断点后，进程在OEP断下</p><p><img src="2023-10-17-01-06-44-image.png"></p><p>继续运行，程序在主函数入口点断下</p><p><img src="2023-10-17-01-07-46-image.png"></p><p>继续运行，程序在输处提示字符串处断下</p><p><img src="2023-10-17-01-08-30-image.png"></p><p>查看参数寄存器</p><img src="2023-10-17-01-09-07-image.png" title="" alt="" width="327"><p>只有rcx一个参数，为<code>请输入flag:\n\r</code>，因此该处调用的函数为<code>puts</code>，后续程序输出时可能还会调用该函数，对函数内下断点</p><p>继续运行到输入字符串位置处断下</p><p><img src="2023-10-17-01-14-43-image.png"></p><p>查看参数寄存器</p><img src="2023-10-17-01-15-10-image.png" title="" alt="" width="343"><p>有两个参数，rcx为格式化字符串<code>&quot;%s&quot;</code>，rdx为地址<code>0x14FE30</code>，因此该处调用函数为<code>printf</code>，<code>0x14FE30</code>为输入缓冲区</p><p>继续运行到<code>printf</code>返回处，查看输入缓冲区<code>0x14FE30</code>处内存</p><p><img src="2023-10-17-01-19-20-image.png"></p><p>此处内存为输入的字符串</p><p>上述操作完成了程序输入和输出的定位，接下来定位程序的校验部分以及结果输出部分</p><p>按<code>G</code>键切换到控制流视图</p><p><a href="./cfg.png">cfg.png</a></p><p>其中的xmm寄存器操作部分可直接跳过，直接查看主函数结尾位置</p><p><img src="2023-10-17-01-27-50-image.png"></p><p>一个分支跳转到程序结尾处，调用<code>sleep</code>等待5000ms显示结果，分支内调用<code>puts</code>函数，根据运行分析可知，当输入字符串时，程序不会输出反馈，输入几秒钟后程序停止，此逻辑正好对于该处代码，因此该代码块的上面应该为校验部分</p><p><img src="2023-10-17-01-31-41-image.png"></p><p>此处明显的串比较特征，从<code>[rax]</code>和<code>[rax+r8]</code>分别取出一个字节进行比较，结束比较的条件为两个字节不相等，或者<code>[rax+r8]</code>处取出的字节为0</p><p>对此处代码下断点，运行程序到该处断下，查看<code>rax</code>、<code>rax+r8</code></p><img src="2023-10-17-01-36-59-image.png" title="" alt="" width="399"><p>rax的值为<code>0x14FE30</code>，与<code>scanf</code>输入的字符串位置相同，字符串仍为输入字符串<code>helloNoxke</code></p><p><img src="2023-10-17-01-39-01-image.png"></p><p>rax+r8的值为<code>0x14FE35</code>，内容为字符串<code>jZiBUViF0WUYwISp4qjx5YwucMNGpb4g</code></p><p>因此该处比较输入字符串与<code>jZiBUViF0WUYwISp4qjx5YwucMNGpb4g</code>是否相等，程序flag为<code>jZiBUViF0WUYwISp4qjx5YwucMNGpb4g</code></p><p>运行程序验证</p><p><img src="2023-10-17-01-43-44-image.png"></p><p>得到正确的程序flag</p>]]></content>
    
    
    <categories>
      
      <category>腾讯游戏客户端安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动端脱壳分析</title>
    <link href="/2023/10/16/TencentGameClient/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%84%B1%E5%A3%B3%E5%88%86%E6%9E%90/"/>
    <url>/2023/10/16/TencentGameClient/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%84%B1%E5%A3%B3%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/noxke/TencentGameClientOpenCourse">GitHub - noxke&#x2F;TencentGameClientOpenCourse: 腾讯游戏客户端公开课2023 腾讯菁英班</a></p><h3 id="DUMP脱壳"><a href="#DUMP脱壳" class="headerlink" title="DUMP脱壳"></a>DUMP脱壳</h3><p>拿到附件先file一下</p><p><img src="2023-10-16-00-53-49-image.png"></p><p>arm平台的ELF文件，因此运行和调试使用手机进行（不需要root）</p><p>ida32打开<code>CrackMe2</code>，进行静态分析</p><img title="" src="2023-10-16-00-57-58-image.png" alt="" data-align="center" width="222"><p>ida只识别出了几个函数，一眼壳，Shift+F12查看字符串，upx加壳</p><img src="2023-10-16-00-59-15-image.png" title="" alt="" width="575"><p>下载upx尝试使用<code>upx -d</code>脱壳</p><img title="" src="2023-10-16-01-00-45-image.png" alt="" width="537"><p>脱不下来，猜测upx特征被隐藏了，因此进行手动脱壳</p><p>先将<code>CrackMe2</code>push到手机，运行测试</p><img src="2023-10-16-01-05-26-image.png" title="" alt="" width="534"><p>程序在等待输入状态，此时upx已经完成解压缩，直接dump内存</p><p>启动idaserver，ida连接idaserver并附加调试</p><img title="" src="2023-10-16-01-07-40-image.png" alt="" width="427"><p>进程在read系统调用断下，根据LR寄存器定位返回地址，下断点，F9恢复进程运行</p><img src="2023-10-16-01-13-41-image.png" title="" alt="" width="426"><p>程序中随意输入字符串<code>1234567890</code>后回车，进程在断点出断下</p><img src="2023-10-16-01-14-23-image.png" title="" alt="" width="424"><p>使用Ctrl+F7运行到返回，直到PC离开libc.so内存空间，函数返回情况如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">syscall_read -&gt; __sread -&gt; __srefill -&gt; __srget -&gt; getc -&gt; debug005+<span class="hljs-number">0x9E64</span><br></code></pre></td></tr></table></figure><img src="2023-10-16-01-19-53-image.png" title="" alt="" width="419"><p>PC离开libc.so内存空间后，返回到debug005段中，因此该段为upx解压之后的可执行段，使用OllyDump插件dump该段内存，选择debug005段</p><img title="" src="2023-10-16-01-25-02-image.png" alt="" width="491"><p>OllyDump自动识别了入口点<code>0x5358</code>，以及存在关联的段，所有参数保持默认，dump为<code>Crackme2_dump.so</code></p><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>使用ida32打开<code>Crackme2_dump.so</code>，自动识别出程序入口点<code>start</code>和主函数<code>main</code></p><img src="2023-10-16-07-44-51-image.png" title="" alt="" width="497"><img title="" src="2023-10-16-07-46-21-image.png" alt="" width="493"><p>在main函数中，显然0x6E2C处为输出提示字符串，Shift+F12查看字符串，定位到如下可能有用的字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">LOAD:<span class="hljs-number">00048000</span> aCatProcNetTcpG DCB <span class="hljs-string">&quot;cat /proc/net/tcp |grep :5D8A&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">0004801</span>E aR DCB <span class="hljs-string">&quot;r&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048020</span> aProcDStatus DCB <span class="hljs-string">&quot;/proc/%d/status&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048030</span> aTracerpid DCB <span class="hljs-string">&quot;TracerPid&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">0004803</span>A aUndebug DCB <span class="hljs-string">&quot;undebug&quot;</span>,<span class="hljs-number">0xA</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048050</span> aDmd2vxkydlvezu DCB <span class="hljs-string">&quot;DMD2vxKYDLvezuriqND2DhP3BJfdtuWWrxe9pq==&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048079</span> aWrongAnswer DCB <span class="hljs-string">&quot;Wrong Answer&quot;</span>,<span class="hljs-number">0xA</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048090</span> aInputYourAnswe DCB <span class="hljs-string">&quot;Input Your Answer:&quot;</span>,<span class="hljs-number">0xA</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">000480B</span>0 aJustForKidding DCB <span class="hljs-string">&quot;just for kidding&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048120</span> aAbcdefghijklmn DCB <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048140</span> aAbcdefghijklmn_0 DCB <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048160</span> a0123456789 DCB <span class="hljs-string">&quot;0123456789+/&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">0004816</span>D aTrueAnswer DCB <span class="hljs-string">&quot;True Answer&quot;</span>,<span class="hljs-number">0</span><br>LOAD:<span class="hljs-number">00048179</span> aWrongAnswer_0 DCB <span class="hljs-string">&quot;Wrong Answer&quot;</span>,<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h5><p>第一个可疑字符串<code>cat /proc/net/tcp |grep :5D8A</code>查看当前的TCP连接情况，<code>0x5D8A</code>转换为十进制为<code>23946</code>，idaserver的默认调试端口，因此此处为检查端口的反调试，查看交叉引用定位到反调试代码</p><p>定位到反调试函数的地址为<code>0x53F4</code>，命名为<code>undebug1</code></p><p>第二个可疑字符串<code>/proc/%d/status</code>，查看进程的状态，根据后续的字符串<code>TracerPid</code>猜测该处是检查进程的<code>TracerPid</code>判断进程是否被调试，查看交叉引用定位到反调试代码</p><img src="2023-10-16-08-05-43-image.png" title="" alt="" width="453"><p>定位到反调试函数地址为<code>0x059D4</code>，命名为<code>undebug2</code></p><p>第三个字符串<code>undebug</code>，是检测到调试器时的输出字符串，查看交叉定位输出该字符串的位置</p><img src="2023-10-16-12-39-09-image.png" title="" alt="" width="455"><p>定位到函数地址为<code>0x5AD0</code>，命名为<code>undebug</code>，该函数调用<code>undebug1</code>和<code>undebug2</code>检测是否被调试，由于<code>undebuge1</code>和<code>undebug2</code>中均没有使程序终止的代码，因此检查调试的入口点为<code>undebug</code></p><h5 id="输入校验"><a href="#输入校验" class="headerlink" title="输入校验"></a>输入校验</h5><p>注意到字符串<code>DMD2vxKYDLvezuriqND2DhP3BJfdtuWWrxe9pq==</code>，典型的base64字符串，尝试解码但发现乱码，猜测解码后的数据为二进制数据或base64码表被替换</p><img src="2023-10-16-12-43-00-image.png" title="" alt="" width="458"><p><code>True Answer</code>应该是输入字符串正确时的输出，根据其交叉引用定位到输出该字符串的位置</p><p>定位到<code>0x7B50</code>函数处，将其命名位<code>check</code></p><img src="2023-10-16-12-53-49-image.png" title="" alt="" width="545"><p>两个分支分别输出<code>Wrong Answer</code>和<code>True Answer</code>，查看该函数的反编译代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c">v6 = <span class="hljs-number">0</span>;<br>v52 = *(_DWORD *)off_47CE8;<br>*a1 = <span class="hljs-number">0</span>;<br>a1[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>a1[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> ( a3 )<br>&#123;<br>    LOBYTE(v41) = v46;<br>    LOBYTE(v7) = v45;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>    v8 = *a2++;<br>    --a3;<br>    *(&amp;v49 + v6++) = v8;<br>    <span class="hljs-keyword">if</span> ( v6 == <span class="hljs-number">3</span> )<br>    &#123;<br>        v9 = v49;<br>        v10 = v51 &amp; <span class="hljs-number">0x3F</span>;<br>        v11 = v50;<br>        v12 = (<span class="hljs-type">char</span> *)dword_48230;<br>        v13 = (v51 &gt;&gt; <span class="hljs-number">6</span>) &amp; <span class="hljs-number">0xFFFFFFC3</span> | (<span class="hljs-number">4</span> * (v50 &amp; <span class="hljs-number">0xF</span>));<br>        v47 = (v51 &gt;&gt; <span class="hljs-number">6</span>) &amp; <span class="hljs-number">0xC3</span> | (<span class="hljs-number">4</span> * (v50 &amp; <span class="hljs-number">0xF</span>));<br>        v48 = v51 &amp; <span class="hljs-number">0x3F</span>;<br>        <span class="hljs-keyword">if</span> ( (byte_48228 &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> )<br>        v12 = algn_48229;<br>        v43 = a3;<br>        v42 = a2;<br>        sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v12[v49 &gt;&gt; <span class="hljs-number">2</span>]);<br>        v14 = (<span class="hljs-type">char</span> *)dword_48230;<br>        <span class="hljs-keyword">if</span> ( (byte_48228 &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> )<br>        v14 = algn_48229;<br>        v41 = (<span class="hljs-number">16</span> * v9) &amp; <span class="hljs-number">0x30</span> | (v11 &gt;&gt; <span class="hljs-number">4</span>);<br>        sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v14[v41]);<br>        v15 = (<span class="hljs-type">char</span> *)dword_48230;<br>        <span class="hljs-keyword">if</span> ( (byte_48228 &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> )<br>        v15 = algn_48229;<br>        sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v15[v13]);<br>        v16 = (<span class="hljs-type">char</span> *)dword_48230;<br>        <span class="hljs-keyword">if</span> ( (byte_48228 &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> )<br>        v16 = algn_48229;<br>        sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v16[v10]);<br>        v7 = v9 &gt;&gt; <span class="hljs-number">2</span>;<br>        a2 = v42;<br>        v6 = <span class="hljs-number">0</span>;<br>        a3 = v43;<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> ( a3 );<br>    v45 = v7;<br>    v46 = v41;<br>    <span class="hljs-keyword">if</span> ( v6 )<br>    &#123;<br>    <span class="hljs-keyword">if</span> ( v6 &lt;= <span class="hljs-number">2</span> )<br>        <span class="hljs-built_in">memset</span>(&amp;v49 + v6, <span class="hljs-number">0</span>, <span class="hljs-number">3</span> - v6);<br>    v45 = v49 &gt;&gt; <span class="hljs-number">2</span>;<br>    v46 = (<span class="hljs-number">16</span> * v49) &amp; <span class="hljs-number">0x30</span> | (v50 &gt;&gt; <span class="hljs-number">4</span>);<br>    v47 = (v51 &gt;&gt; <span class="hljs-number">6</span>) &amp; <span class="hljs-number">0xC3</span> | (<span class="hljs-number">4</span> * (v50 &amp; <span class="hljs-number">0xF</span>));<br>    v48 = v51 &amp; <span class="hljs-number">0x3F</span>;<br>    <span class="hljs-keyword">if</span> ( v6 &gt;= <span class="hljs-number">0</span> )<br>    &#123;<br>        v17 = (<span class="hljs-type">char</span> *)dword_48230;<br>        <span class="hljs-keyword">if</span> ( (byte_48228 &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> )<br>        v17 = algn_48229;<br>        sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v17[v49 &gt;&gt; <span class="hljs-number">2</span>]);<br>        v18 = v6;<br>        v19 = &amp;v46;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>        v20 = (<span class="hljs-type">char</span> *)dword_48230;<br>        v22 = (<span class="hljs-type">unsigned</span> __int8)*v19++;<br>        v21 = v22;<br>        <span class="hljs-keyword">if</span> ( (byte_48228 &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> )<br>            v20 = algn_48229;<br>        sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v20[v21]);<br>        --v18;<br>        &#125;<br>        <span class="hljs-keyword">while</span> ( v18 );<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( v6 &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        v23 = <span class="hljs-number">3</span> - v6;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>        sub_8430(a1, <span class="hljs-number">61</span>);<br>        --v23;<br>        &#125;<br>        <span class="hljs-keyword">while</span> ( v23 );<br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到该if内有明显的base64编码特征</p><p>每次从a2中取出三个字符，依次存放在v49, v50, v51中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span><br>&#123;<br>    v8 = *a2++;<br>    --a3;<br>    *(&amp;v49 + v6++) = v8;<br>    <span class="hljs-keyword">if</span> ( v6 == <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-comment">/******/</span><br>        v6 = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">while</span> ( a3 );<br></code></pre></td></tr></table></figure><p>对第一个字符取高6位作为索引查表，然后由<code>sub_8430</code>处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v12[v49 &gt;&gt; <span class="hljs-number">2</span>]);<br></code></pre></td></tr></table></figure><p>对第一个字符取低两位，第二个字符取高4位，组合为6位，作为索引查表，然后由<code>sub_8430</code>处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">v9 = v49;<br>v11 = v50;<br>v41 = (<span class="hljs-number">16</span> * v9) &amp; <span class="hljs-number">0x30</span> | (v11 &gt;&gt; <span class="hljs-number">4</span>);<br>sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v14[v41]);<br></code></pre></td></tr></table></figure><p>对第二个字符取低4位，第三个字符取高两位，组合为6位，作为索引查表，然后由<code>sub_8430</code>处理 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">v13 = (v51 &gt;&gt; <span class="hljs-number">6</span>) &amp; <span class="hljs-number">0xFFFFFFC3</span> | (<span class="hljs-number">4</span> * (v50 &amp; <span class="hljs-number">0xF</span>));<br>sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v15[v13]);<br></code></pre></td></tr></table></figure><p>对第三个字符取低6位，作为索引查表，然后由<code>sub_8430</code>处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">v10 = v51 &amp; <span class="hljs-number">0x3F</span>;<br>sub_8430(a1, (<span class="hljs-type">unsigned</span> __int8)v16[v10]);<br></code></pre></td></tr></table></figure><p>后续不足3个字符的一次此处省略分析，分析发现存在两个关键点，一是base64编码的码表<code>(char *)dword_48230</code>，二是<code>sub_8430</code>函数</p><p>base64编码结束的地址为<code>0x7D84</code></p><p><code>0x48230</code>储存的是码表的地址，未在dump的文件中，后续动态调试时分析</p><p><code>0x8430</code>处函数较为复杂，但是由于其输入简单，因此考虑在动态调试时分析</p><p>上述代码对参数字符串a2使用base64编码，分析<code>check</code>函数剩余代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">v24 = *(<span class="hljs-type">unsigned</span> __int8 *)a1;<br>v25 = a1[<span class="hljs-number">1</span>];<br>v26 = *a4;<br>v27 = *((_DWORD *)a4 + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> ( (v26 &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span> )<br>    v27 = v26 &gt;&gt; <span class="hljs-number">1</span>;<br>v28 = v24 &amp; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> ( (v24 &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> )<br>    v25 = v24 &gt;&gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>在<code>check</code>函数开始时，<code>a1[0], a1[1], a1[2]</code>均被设为0，但a1作为<code>sub_8430</code>参数，多次参入base64编码的过程，且在最后的判断中，多个值从<code>a1</code>处读取，猜测<code>a1</code>处可能储存base64编码的结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( v27 )<br>&#123;<br>    v32 = -(v26 &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> ( *v31 == *v29 )<br>    &#123;<br>    ++v32;<br>    ++v29;<br>    ++v31;<br>    <span class="hljs-keyword">if</span> ( !v32 )<br>        <span class="hljs-keyword">goto</span> LABEL_43;<br>    &#125;<br>    <span class="hljs-keyword">goto</span> LABEL_42;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码进行字符串比较，关键判断</p><h5 id="动态调试分析"><a href="#动态调试分析" class="headerlink" title="动态调试分析"></a>动态调试分析</h5><p>根据上述动态调试分析，获得以下需要断点的位置</p><ul><li><p>getc返回地址<code>debug005+0x9E64</code></p><blockquote><p>getc处为Thumb模式，需要使用Alt+g将Thumb标准设为1进行解析</p></blockquote></li><li><p>undebug反调试函数<code>debug005+0x5AD0</code></p></li><li><p>check函数<code>debug005+0x7B50</code></p></li><li><p>base64编码结束位置<code>debug005+0x7D84</code></p></li></ul><p>需要重点分析的内存区域有：</p><ul><li><p>check函数参数寄存器<code>R0</code></p></li><li><p>check函数参数寄存器<code>R3</code></p></li><li><p>base64编码码表<code>debug005+0x48230</code></p></li></ul><p>由于dump得到的elf文件中部分地址存储的值错误，不能之间进行运行调试，因此继续对<code>CrackMe2</code>进行附加调试</p><p>按照dump过程进行附加调试，进程断下后对上述地址下断点恢复运行，随意输入字符串<code>1234567890</code></p><p>getc返回位置断下</p><img src="2023-10-16-14-07-28-image.png" title="" alt="" width="494"><p>取消断点，F9继续运行，undebug函数断下</p><img src="2023-10-16-14-09-26-image.png" title="" alt="" width="495"><p>手动将PC设到LR寄存器指向的返回地址处</p><img src="2023-10-16-14-10-33-image.png" title="" alt="" width="497"><p>F9继续运行</p><img src="2023-10-16-14-11-12-image.png" title="" alt="" width="499"><p>check函数断下，寄存器如下</p><img src="2023-10-16-16-39-43-image.png" title="" alt="" width="274"><p>记录R0寄存器的值<code>0xFFBAA758</code></p><p>查看R1地址处（a2参数），很明显为输入的字符串</p><img src="2023-10-16-16-40-18-image.png" title="" alt="" width="496"><p>R2的值（a3参数）为<code>0xA</code>，很明显为输入字符串的长度</p><p>查看R3地址处(a4参数)，<code>0x21</code></p><img src="2023-10-16-16-40-50-image.png" title="" alt="" width="493"><p>查看base64编码码表<code>debug005+0x48230</code></p><img src="2023-10-16-16-42-09-image.png" title="" alt="" width="491"><img title="" src="2023-10-16-16-43-31-image.png" alt="" width="486"><p>注意到该码表与标准base64码表不同，标准base64大写字母在前，小写字母在后，而此处相反，因此经过编码后的字符串大小写与标准base64编码相反</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> string<br><br>str1 = <span class="hljs-string">&quot;1234567890&quot;</span><br><br>alpha_table = <span class="hljs-string">&quot;\</span><br><span class="hljs-string">ABCDEFGHIJKLMNOPQRSTUVWXYZ\</span><br><span class="hljs-string">abcdefghijklmnopqrstuvwxyz\</span><br><span class="hljs-string">0123456789+/&quot;</span><br>alpha_table2 = <span class="hljs-string">&quot;\</span><br><span class="hljs-string">abcdefghijklmnopqrstuvwxyz\</span><br><span class="hljs-string">ABCDEFGHIJKLMNOPQRSTUVWXYZ\</span><br><span class="hljs-string">0123456789+/&quot;</span><br>trans = str1.maketrans(alpha_table, alpha_table2)<br><br>str1_b64 = base64.b64encode(str1.encode()).decode()<br>str1_b64_2 = str1_b64.translate(trans)<br><span class="hljs-built_in">print</span>(str1_b64)<br><span class="hljs-comment"># MTIzNDU2Nzg5MA==</span><br><span class="hljs-built_in">print</span>(str1_b64_2)<br><span class="hljs-comment"># mtiZndu2nZG5ma==</span><br></code></pre></td></tr></table></figure><p>F9运行到对输入字符串base64编码完成处<code>debug005+0x7D84</code>，查看之前记录的R0中地址处内容<code>0xFFBAA758</code></p><img src="2023-10-16-16-48-38-image.png" title="" alt="" width="492"><p>第一个值为<code>0x21</code>，根据前面的分析，可能是待比较的数据长度，第二个值为<code>0x10</code>，可能为输入字符串编码后的长度，第三个值为地址<code>0xF67450A0</code>，查看该地址处内存</p><img src="2023-10-16-17-07-13-image.png" title="" alt="" width="494"><p>地址处的值为输入字符串编码后的b64字符串<code>mtiZndu2nZG5ma==</code>，与上述测试相同，该地址<code>-0x20</code>处为另一个b64字符串<code>vgvUy2vUDeDHBwvtzwn1CML0Eq==</code>，猜测为待比较的字符串，使用base64解码测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">str2_b64 = <span class="hljs-string">&quot;vgvUy2vUDeDHBwvtzwn1CML0Eq==&quot;</span><br>str2_b64_2 = str2_b64.translate(trans)<br>str2 = base64.b64decode(str2_b64_2.encode()).decode()<br><span class="hljs-built_in">print</span>(str2)<br><span class="hljs-comment"># TencentGameSecurity</span><br></code></pre></td></tr></table></figure><p>解码得到字符串<code>TencentGameSecurity</code>，猜测可能为flag</p><p>ida继续调试，运行到第一个判断分枝</p><img src="2023-10-16-17-15-14-image.png" title="" alt="" width="502"><p>此时R2为<code>0x1C</code>，<code>vgvUy2vUDeDHBwvtzwn1CML0Eq==</code>字符串的长度</p><p>R0为<code>0x10</code>，<code>mtiZndu2nZG5ma==</code>字符串的长度</p><p>当两个字符串长度不相等时，跳转到输出<code>Wrong Answer</code>，手动修改R0寄存器为<code>0x1C</code>，跳过该判断</p><img src="2023-10-16-17-20-17-image.png" title="" alt="" width="509"><p>运行到第二个分枝，仍然手动跳过</p><img src="2023-10-16-17-24-37-image.png" title="" alt="" width="507"><p>运行到循环进行比较的位置，比较R1和R3处字符串是否相等</p><img src="2023-10-16-17-25-54-image.png" title="" alt="" width="286"><p>查看寄存器发现R1指向字符串<code>mtiZndu2nZG5ma==</code>，但R3未指向另一字符串，猜测在手动跳转时可能导致寄存器改变错误</p><p>中断进程，对上述得到的疑似flag<code>TencentGameSecurity</code>进行测试</p><img src="2023-10-16-17-34-27-image.png" title="" alt="" width="582"><p><code>Trun Answer</code>，说明确实是正确的flag</p><p>静态分析时得到一个使用base64解码乱码的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">LOAD:00048050 aDmd2vxkydlvezu DCB <span class="hljs-string">&quot;DMD2vxKYDLvezuriqND2DhP3BJfdtuWWrxe9pq==&quot;</span>,<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>猜测其编码码表被替换，对其重新解码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">str3_b64 = <span class="hljs-string">&quot;DMD2vxKYDLvezuriqND2DhP3BJfdtuWWrxe9pq==&quot;</span><br>str3_b64_2 = str3_b64.translate(trans)<br>str3 = base64.b64decode(str3_b64_2.encode()).decode()<br><span class="hljs-built_in">print</span>(str3)<br><span class="hljs-comment"># vgvUy2vUDeDHBwvtzwn1CML0Eq==</span><br></code></pre></td></tr></table></figure><p>解码出来的字符串是<code>vgvUy2vUDeDHBwvtzwn1CML0Eq==</code>，再解码一次就是flag<code>TencentGameSecurity</code></p><h3 id="upx-d脱壳"><a href="#upx-d脱壳" class="headerlink" title="upx -d脱壳"></a>upx -d脱壳</h3><p>经过调试解压缩过程，发现该壳明显就是原版的upx,无法直接<code>upx -d</code>说明修改了，特征字段，编译一个测试文件进行加壳对照分析</p><p>使用010editor打开<code>CrackMe2</code>和对照文件，两个文件都为3个节区，理论上每个节区都存在<code>UPX!</code>关键字，搜索关键字<code>UPX!</code></p><img src="2023-10-16-17-40-06-image.png" title="" alt="" width="451"><img src="2023-10-16-17-40-29-image.png" title="" alt="" width="453"><p>发现<code>CrackMe2</code>只搜索到3个<code>UPX!</code>关键字，而对照文件有4个，对照文件中4个<code>UPX!</code>第一个分布在文件开始位置不远处，第二个位于中间位置，后两个位于文件末尾，并且后两个距离很近，而<code>CrackMe2</code>末尾处只有两个<code>UPX!</code>关键字</p><p>定位到文件末尾</p><img src="2023-10-16-17-44-28-image.png" title="" alt="" width="456"><img src="2023-10-16-17-44-55-image.png" title="" alt="" width="460"><p>将<code>CrackMe2</code>对应位置处修改为<code>UPX!</code></p><img src="2023-10-16-17-45-59-image.png" title="" alt="" width="466"><p>保存文件使用<code>upx -d</code>脱壳</p><img src="2023-10-16-17-47-27-image.png" title="" alt="" width="464"><p>脱壳成功，使用ida打开脱壳文件分析</p><img src="2023-10-16-17-48-51-image.png" title="" alt="" width="474"><img src="2023-10-16-17-49-54-image.png" title="" alt="" width="478"><p>程序的函数以及代码都能够正常分析，但是字符串未正常解析，无法快速定位，根据之前的分析可以知道字符串是在程序运行时解码生成的</p><p>尝试运行脱壳后的文件</p><img src="2023-10-16-17-52-38-image.png" title="" alt="" width="482"><p>能够正常运行，输入flag<code>TencentGameSecurity</code>后能够正确判断</p>]]></content>
    
    
    <categories>
      
      <category>腾讯游戏客户端安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01关于逆向工程</title>
    <link href="/2023/10/12/reverse_core/01%E5%85%B3%E4%BA%8E%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <url>/2023/10/12/reverse_core/01%E5%85%B3%E4%BA%8E%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>逆向工程核心原理一书非常适合逆向初学者进行学习，该书以Windows x86为平台，详细介绍了逆向中的调试分析技巧</p><p>本系列文章将对书籍中的内容进行记录</p></blockquote><h3 id="逆向工程常用分析方法"><a href="#逆向工程常用分析方法" class="headerlink" title="逆向工程常用分析方法"></a>逆向工程常用分析方法</h3><ul><li><p>静态分析</p><p>在不执行代码文件的情形下，对大妈进行静态分析，观察代码文件的外部特征，通常会查看文件的类型、大小、PE头信息、导入导出表、字符串等信息。此外还会使用反汇编和反编译工具查看内部代码、分析代码结构。</p></li><li><p>动态分析</p><p>动态分析是在程序文件执行过程中对代码进行分析、通过动态调试来分析代码流，获取内存状态等，动态分析常使用调试器分析程序的内部结构和动作原理。</p></li></ul><p>在逆向分析程序时，通常静态分析与动态分析相互结合，在静态分析的过程中猜测代码的功能，对存在分析价值的代码下断点、快速跳过不重要的代码，提高动态分析的效率，在动态分析时对静态分析时的猜测进行验证，确保分析的准确性。</p><h3 id="逆向的准备"><a href="#逆向的准备" class="headerlink" title="逆向的准备"></a>逆向的准备</h3><ul><li><p>C语言</p><p>在进行逆向分析时，需要能够揣测开发者的开发思路、对常见的代码结构有所了解，因此需要具备正向开发的基础</p></li><li><p>汇编语言</p><p>在逆向分析时，虽然可以使用IDA将汇编代码反编译为C代码，但是反编译的代码在大多数情况下存在错误，并且并非所有情况都能将汇编代码进行反编译，因此需要对汇编指令有较多的了解、了解汇编中分支调整、函数调用等过程，能够根据汇编代码还原程序的逻辑</p></li><li><p>兴趣和大量的时间</p><p>首先需要了解自己为什么要学习逆向分析技术，如果只是以破解游戏软件为目的，并不建议系统学习逆向分析技术。</p><p>逆向分析是一个及其耗费时间的过程，需要有足够得耐心。</p><blockquote><p>学习代码逆向分析技术的过程中，有时候会遇到挫折，让人感到厌倦，这可能会让我们暂停学习。不过，只要保持对逆向分析技术的激情，我们就不会放弃，而会再次挑战。通过一次又一次得尝试，我们最终会成为代码逆向分析专家。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>逆向工程核心原理二周目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游戏客户端开发基础-移动篇</title>
    <link href="/2023/10/09/TencentGameClient/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-%E7%A7%BB%E5%8A%A8%E7%AF%87/"/>
    <url>/2023/10/09/TencentGameClient/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-%E7%A7%BB%E5%8A%A8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/noxke/TencentGameClientOpenCourse">GitHub - noxke&#x2F;TencentGameClientOpenCourse: 腾讯游戏客户端公开课2023 腾讯菁英班</a></p><h3 id="1-Java层分析"><a href="#1-Java层分析" class="headerlink" title="1.Java层分析"></a>1.Java层分析</h3><p>使用jadx打开题目apk，查看AndroidManifest.xml获取程序入口Activity为<code>com.example.crackme1.MainActivity</code></p><p>查看反编译的<code>MainActivity</code>类的<code>onCreate</code>方法，分析Java层逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>    <span class="hljs-type">ActivityMainBinding</span> <span class="hljs-variable">inflate</span> <span class="hljs-operator">=</span> ActivityMainBinding.inflate(getLayoutInflater());<br>    <span class="hljs-built_in">this</span>.binding = inflate;<br>    setContentView(inflate.getRoot());<br>    <span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> (Button) findViewById(C0462R.C0465id.button);<br>    <span class="hljs-built_in">this</span>.btn1 = button;<br>    button.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123; <span class="hljs-comment">// from class: com.example.crackme1.MainActivity.1</span><br>        <span class="hljs-meta">@Override</span> <span class="hljs-comment">// android.view.View.OnClickListener</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>            <span class="hljs-type">EditText</span> <span class="hljs-variable">textInput</span> <span class="hljs-operator">=</span> (EditText) MainActivity.<span class="hljs-built_in">this</span>.findViewById(C0462R.C0465id.TextInput);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">Inputstr</span> <span class="hljs-operator">=</span> textInput.getText().toString();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">RetStr</span> <span class="hljs-operator">=</span> MainActivity.<span class="hljs-built_in">this</span>.stringFromJNI(Inputstr);<br>            Toast.makeText(MainActivity.<span class="hljs-built_in">this</span>, RetStr, <span class="hljs-number">0</span>).show();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>按钮触发点击事件后，调用<code>onClick</code>方法，获取输入框的输入字符串<code>Inputstr</code>，将输入字符串<code>Inputstr</code>调用<code>stringFromJNI</code>方法，并将返回字符串<code>RetStr</code>显示为toast消息</p><p>查看处理字符串的<code>stringFromJNI</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> String <span class="hljs-title function_">stringFromJNI</span><span class="hljs-params">(String str)</span>;<br><br><span class="hljs-keyword">static</span> &#123;<br>    System.loadLibrary(<span class="hljs-string">&quot;crackme1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法为native文件<code>libcrackme1.so</code>中的导出函数</p><p>使用Android Studio打开apk文件进行调试，对<code>onClick</code>方法中的<code>stringFromJNI</code>调用行下断点，开始调试运行</p><p><img src="2023-10-09-11-15-05-image.png"></p><p><img src="2023-10-09-11-15-22-image.png"></p><p>调用<code>stringFromJNI</code>前，参数寄存器v0为输入的字符串，单步跳过该行调用，查看返回值</p><p><img src="2023-10-09-11-17-23-image.png"></p><p>返回值v2寄存器为字符串<code>Wrong</code>，继续运行程序，字符串<code>wrong</code>以toast消息显示在屏幕上</p><p><img src="2023-10-09-11-18-57-image.png"></p><p><img src="2023-10-09-11-19-20-image.png"></p><p>查看logcat发现，调用<code>stringFromJNI</code>函数时程序会打印log信息<code>Str:...</code>，并且每次点击按钮调用函数时打印的字符串均不相同</p><h3 id="2-Native层分析"><a href="#2-Native层分析" class="headerlink" title="2.Native层分析"></a>2.Native层分析</h3><p>分析和调试Java层发现，程序的字符串校验功能位于native层的<code>stringFromJNI</code>函数中，该函数为<code>libcrackme1.so</code>动态库的导出函数，该库文件位于<code>crackme1/lib/armeabi-v7a/</code>目录下，因此程序需要使用支持armabi-v7a的设备运行</p><p>使用readelf工具查看<code>libcrackme1.so</code>的导出函数</p><p><img src="2023-10-09-11-27-47-image.png"></p><p><code>stringFromJNI</code>函数偏移地址为<code>0x1194</code>，函数偏移最低位为0，Arm模式执行</p><p>使用ida32打开<code>libcrackme1.so</code>文件查看<code>stringFromJNI</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __fastcall <span class="hljs-title function_">Java_com_example_crackme1_MainActivity_stringFromJNI</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2, <span class="hljs-type">int</span> a3)</span><br>&#123;<br>  <span class="hljs-type">char</span> *s2; <span class="hljs-comment">// [sp+Ch] [bp-7Ch]</span><br>  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [sp+20h] [bp-68h] BYREF</span><br><br>  s2 = (<span class="hljs-type">char</span> *)sub_12A4(a1, a3, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">memset</span>(s, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(s));<br>  qmemcpy(s, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">3</span>);<br>  sub_F50(<span class="hljs-number">5</span>, s);<br>  <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strncmp</span>(s, s2, <span class="hljs-number">5u</span>) || (sub_1134() &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span> )<br>    <span class="hljs-keyword">return</span> sub_12EC(a1, <span class="hljs-string">&quot;right&quot;</span>);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> sub_12EC(a1, <span class="hljs-string">&quot;wrong&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据反编译c代码，函数将输入字符串<code>s2</code>与<code>sub_F50</code>函数生成的字符串s进行比较，当比较结果相同时，返回字符串<code>right</code>，不同时返回结果<code>wrong</code></p><p>查看<code>sub_F50</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __fastcall <span class="hljs-title function_">sub_F50</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *a2)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v2; <span class="hljs-comment">// r0</span><br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// r1</span><br>  <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [sp+8h] [bp-28h]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [sp+14h] [bp-1Ch]</span><br>  <span class="hljs-type">size_t</span> v9; <span class="hljs-comment">// [sp+2Ch] [bp-4h]</span><br><br>  v2 = time(<span class="hljs-number">0</span>);<br>  srand(v2);<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; a1; ++i )<br>  &#123;<br>    v5 = rand();<br>    v9 = _strlen_chk(a0123456789abcd, <span class="hljs-number">0x40</span>u);<br>    sub_2964(v5, v9);<br>    a2[i] = a0123456789abcd[v3];<br>  &#125;<br>  a2[i] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> _android_log_print(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Crack&quot;</span>, <span class="hljs-string">&quot;Str:%s&quot;</span>, a2);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数生成一个随机字符串，并在log中打印该字符串，因此在log中看到的<code>Str:...</code>就是进行比较的字符串</p><p>在if判断中，除了比较字符串是否相等，还对<code>sub_1134</code>函数返回值进行判断，分析该函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sub_1134</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img title="" src="2023-10-09-12-09-13-image.png" alt="" width="475"><p>反编译的c代码中该函数直接返回0,但根据汇编代码，该函数内存在打印log信息的函数调用，提示<code>hook this func to return true</code>，但该分支永远不会执行，因此logcat中未查看到该log信息，按照提示，后续选择该函数进行hook，其偏移地址为<code>0x1134</code>，后续称为<code>proc</code>，函数偏移地址最低为为0，Arm模式执行</p><p>查看<code>/proc/pid/maps</code>文件查看<code>libcrackme1.so</code>内存映射信息</p><p><img src="2023-10-09-12-23-02-image.png"></p><p><code>libcrackme1.so</code>的加载基地址为<code>0xe36f0000</code>，因此<code>stringFromJNI</code>函数在内存中的地址为<code>0xe36f1194</code></p><p>ida对<code>stringFromJNI</code>和<code>proc</code>下断点，附加到<code>com.example.crackme1</code>进程进行调试</p><p>调试器附加后发现线程13032触发了SIGABRT信号，导致程序中断，如果继续运行程序将信号传送给进程，程序会崩溃无法调试，该处需要将对产生该信号的线程挂起，并忽略该信号避免该线程恢复运行</p><img src="2023-10-09-12-16-24-image.png" title="" alt="" width="290"><img src="2023-10-09-12-16-40-image.png" title="" alt="" width="293"><img src="2023-10-09-12-17-08-image.png" title="" alt="" width="294"><p>在程序输入字符串点击确认按钮，Android Studio单步执行<code>stringFromJNI</code>方法，ida在<code>stringFromJNI</code>函数入口断下，函数地址为<code>0xe36f1194</code>，与上述计算相同</p><img title="" src="2023-10-09-12-24-14-image.png" alt="" width="493"><p>运行到生成随机字符串的函数返回，strcmp之前，查看两个字符串内容</p><img title="" src="2023-10-09-12-27-51-image.png" alt="" width="491"><img title="" src="2023-10-09-12-28-08-image.png" alt="" width="485"><img title="" src="2023-10-09-12-28-27-image.png" alt="" width="482"><p>分别为生成的随机字符串和输入字符串，查看log信息</p><img title="" src="2023-10-09-12-29-33-image.png" alt="" width="479"><p>log打印的字符串为函数生成的随机字符串</p><p>断点到<code>proc</code>函数</p><img title="" src="2023-10-09-12-34-04-image.png" alt="" width="479"><p>对函数的BEQ执行进行修改，使起能够打印log信息，并在函数返回时，将返回值R0寄存器修改为1</p><img title="" src="2023-10-09-12-35-36-image.png" alt="" width="477"><p>出现<code>hook this func to return true</code>log信息，继续运行程序，使<code>stringFromJNI</code>函数返回</p><p><img src="2023-10-09-12-37-39-image.png"></p><p>smali代码中<code>stringFromJNI</code>返回<code>right</code>，继续运行程序，屏幕显示toast消息<code>right</code></p><h3 id="3-ptrace注入程序"><a href="#3-ptrace注入程序" class="headerlink" title="3.ptrace注入程序"></a>3.ptrace注入程序</h3><p>使用ptrace注入程序大致分为以下几个步骤</p><ul><li><p>使用PTRACE_ATTACH附加的进程</p></li><li><p>手动调用malloc函数在进程内分配内存</p></li><li><p>使用PTRACE_WRITE将要注入的so文件路径写入进程内存</p></li><li><p>手动调用dlopen函数将so文件加载到进程内存</p></li><li><p>使用PTRACE_CONT恢复进程运行，使用PTRACE_DETACH从进程脱离</p></li></ul><p>其中需要手动调用的函数<code>malloc</code>位于<code>libc.so</code>中，函数<code>dlopen</code>位于<code>libdl.so</code>中，使用readelf查看<code>libc.so</code>和<code>libdl.so</code>的导出信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb shell<br>lmipro:/ $ su<br>lmipro:/ # readelf -s -W /apex/com.android.runtime/lib/bionic/libc.so |\<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">grep malloc</span><br>   536: 0002d685    76 FUNC    GLOBAL DEFAULT   17 malloc<br><br>lmipro:/ # readelf -s -W /apex/com.android.runtime/lib/bionic/libdl.so |\                                                                             <br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">grep dlopen</span><br>    19: 00001849    10 FUNC    WEAK   DEFAULT   10 dlopen<br></code></pre></td></tr></table></figure><p><code>malloc</code>函数的偏移地址为<code>0x2d685</code>，<code>dlopen</code>函数的编译地址为<code>0x1849</code>，注意到两个函数偏移地址最低位都是1，处理器在执行这两个函数时需要进入Thumb模式</p><blockquote><p>Armv7a处理器指令集指令长度为4字节，当处理器进入Thumb模式后，指令长度为2字节，或拓展长度为4字节，当PC跳转的目的地址指令最低为为1时，处理器需要进入Thumb模式，置CPSR寄存器第5位为1，当恢复arm模式时，置CPSR寄存器第5位为0</p><img title="" src="2023-10-09-12-56-17-image.png" alt="" width="394"><p>在c标准函数调用时，前4个参数依次存放在R0~R3寄存器中，剩余的参数从右向左依次压入栈中，返回地址存放在LR寄存器中，返回值存放在R0寄存器中</p></blockquote><p>使用ptrace手动调用函数时，需要先使用PTRACE_GETREGS保存进程的寄存器信息，然后减小SP寄存器创建栈帧，将函数参数依次存放到R0~R3寄存器中，剩余参数存放到栈中，然后根据函数地址设置PC寄存器和CPSR寄存器，PC寄存器设置为函数地址，最低位置0，根据函数地址最低位设置CPSR寄存器Thumb模式标志为，然后设置LR寄存器为0,使函数返回时，触发错误停止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// PC寄存器，低位决定处理器模式</span><br>regs.uregs[<span class="hljs-number">15</span>] = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)proc_addr &amp; <span class="hljs-number">0xFFFFFFFE</span>);<br><span class="hljs-comment">// PSR寄存器，第5位决定Thumb模式,根据函数地址最低位确定是否进入Thumb模式</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)proc_addr &amp; <span class="hljs-number">0x1</span>)<br>&#123;<br>    <span class="hljs-comment">// Thumb模式</span><br>    regs.uregs[<span class="hljs-number">16</span>] = regs.uregs[<span class="hljs-number">16</span>] | <span class="hljs-number">0x20</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">// arm模式</span><br>    regs.uregs[<span class="hljs-number">16</span>] = regs.uregs[<span class="hljs-number">16</span>] &amp; <span class="hljs-number">0xFFFFFFDF</span>;<br>&#125;<br><span class="hljs-comment">// LR寄存器</span><br>regs.uregs[<span class="hljs-number">14</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>完成寄存器设置后，使用PTRACE_SETREGS将设置进程寄存器为修改后的寄存器，使用PTRACE_CONT恢复进程运行，waitpid等待进程触发返回异常,当进程触发返回异常断下是，waitpid返回状态码为<code>0xb7f</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ptrace_setregs(pid, &amp;regs) != <span class="hljs-number">0</span> || ptrace_continue(pid) != <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;call proc 0x%lx failed\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)proc_addr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">// 等待函数执行完返回错误</span><br>waitpid(pid, &amp;status, WUNTRACED);<br><span class="hljs-comment">// printf(&quot;0x%x\n&quot;, status);</span><br><span class="hljs-keyword">while</span> (status != <span class="hljs-number">0xb7f</span>)<br>&#123;<br>    ptrace_continue(pid);<br>    waitpid(pid, &amp;status, WUNTRACED);<br>&#125;<br></code></pre></td></tr></table></figure><p>进程返回后，使用PTRACE_GETREGS获取寄存器，读取返回值R0寄存器，并使用调用函数前保存的寄存器恢复进程寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">ptrace_getregs(pid, &amp;regs);<br><span class="hljs-comment">// 返回值在R0中</span><br>ret = (<span class="hljs-type">void</span> *)regs.uregs[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 恢复寄存器</span><br>ptrace_setregs(pid, &amp;saved_regs);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;proc 0x%lx return value: 0x%lx\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)proc_addr, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ret);<br><span class="hljs-keyword">return</span> ret;<br></code></pre></td></tr></table></figure><p>调用<code>malloc</code>函数和<code>dlopen</code>函数之前，需要获取函数在内存中的加载地址，读取<code>/proc/self/maps</code>文件可以得到<code>libc.so</code>和<code>libdl.so</code>加载的基地址，使用<code>dlopen</code>加载so文件，使用<code>dlsym</code>可以获得<code>malloc</code>和<code>dlopen</code>函数在注入器进程中的加载地址，与so文件基地址相减得到偏移地址，然后读取<code>/proc/pid/maps</code>文件可以获取待注入进程中<code>libc.so</code>和<code>libdl.so</code>加载基地址，根据偏移地址得到<code>malloc</code>和<code>dlopen</code>在待注入进程中的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取proc函数的内存地址</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">get_remote_proc_addr</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *lib_path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *proc_name)</span><br>&#123;<br>    <span class="hljs-type">void</span> *handle;<br>    <span class="hljs-type">void</span> *local_module_base;<br>    <span class="hljs-type">void</span> *local_proc_addr;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> proc_offset;<br>    <span class="hljs-type">void</span> *remote_module_base;<br>    <span class="hljs-type">void</span> *remote_proc_addr;<br>    <span class="hljs-comment">// 在本地加载lib文件并获取proc函数偏移</span><br>    handle = dlopen(lib_path, RTLD_LAZY);<br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open %s failed\n&quot;</span>, lib_path);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    dlerror();<br>    local_module_base = get_module_base(<span class="hljs-number">0</span>, lib_path);<br>    local_proc_addr = dlsym(handle, proc_name);<br>    proc_offset = local_proc_addr - local_module_base;<br>    dlclose(handle);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s offset: 0x%lx\n&quot;</span>, proc_name, proc_offset);<br>    remote_module_base = get_module_base(pid, lib_path);<br>    remote_proc_addr = remote_module_base + proc_offset;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s address: 0x%lx\n&quot;</span>, proc_name, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)remote_proc_addr);<br>    <span class="hljs-keyword">return</span> remote_proc_addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>注入器函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 注入so到进程</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inject_lib</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *lib_path)</span><br>&#123;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">void</span> *params[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">void</span> *proc_malloc;<br>    <span class="hljs-type">void</span> *proc_dlopen;<br>    <span class="hljs-type">void</span> *proc_dlerror;<br>    <span class="hljs-type">void</span> *mem_buf;<br>    proc_malloc = get_remote_proc_addr(pid, libc_path, <span class="hljs-string">&quot;malloc&quot;</span>);<br>    proc_dlopen = get_remote_proc_addr(pid, libdl_path, <span class="hljs-string">&quot;dlopen&quot;</span>);<br>    proc_dlerror = get_remote_proc_addr(pid, libdl_path, <span class="hljs-string">&quot;dlerror&quot;</span>);<br>    <span class="hljs-comment">// 首先附加到进程</span><br>    ptrace_attach(pid);<br>    <span class="hljs-comment">// 调用malloc分配内存写入lib文件路径</span><br>    params[<span class="hljs-number">0</span>] = (<span class="hljs-type">void</span> *)<span class="hljs-number">0x100</span>;<br>    mem_buf = ptrace_call(pid, proc_malloc, <span class="hljs-number">1</span>, params);<br>    <span class="hljs-keyword">if</span> (mem_buf == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc memory failed\n&quot;</span>);<br>        ptrace_continue(pid);<br>        ptrace_detach(pid);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc memory at 0x%lx\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)mem_buf);<br>    <span class="hljs-comment">// 将lib路径写入进程内存</span><br>    ptrace_write(pid, mem_buf, <span class="hljs-built_in">strlen</span>(lib_path) + <span class="hljs-number">1</span>, (<span class="hljs-type">void</span> *)lib_path);<br>    <span class="hljs-comment">// 调用dlopen将lib文件加载到进程</span><br>    params[<span class="hljs-number">0</span>] = mem_buf;<br>    params[<span class="hljs-number">1</span>] = (<span class="hljs-type">void</span> *)RTLD_LAZY;<br>    <span class="hljs-keyword">if</span> (ptrace_call(pid, proc_dlopen, <span class="hljs-number">2</span>, params) == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dlopen load %s to process %d failed\n&quot;</span>, lib_path, pid);<br>        <span class="hljs-comment">// 调用dlerror查看错误原因</span><br>        <span class="hljs-type">void</span> *err_addr = ptrace_call(pid, proc_dlerror, <span class="hljs-number">0</span>, params);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> err[<span class="hljs-number">0x100</span>];<br>        ptrace_read(pid, err_addr, <span class="hljs-number">0x100</span>, (<span class="hljs-type">void</span> *)err);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, err);<br>        ptrace_continue(pid);<br>        ptrace_detach(pid);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dlopen load %s to process %d succeed\n&quot;</span>, lib_path, pid);<br>    ptrace_continue(pid);<br>    ptrace_detach(pid);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译注入器上传到手机进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">❯ armv7a-linux-androideabi33-clang -o injector ptrace_injector.c<br>❯ adb push injector /data/local/tmp<br>injector: 1 file pushed, 0 skipped. 130.1 MB/s (11088 bytes in 0.000s)<br><br>❯ adb shell<br>lmipro:/ $ su<br>lmipro:/ # cd /data/local/tmp<br>lmipro:/data/local/tmp # ./injector com.example.crackme1 /data/local/tmp/libhook.so<br>pid of com.example.crackme1: 21551<br>/apex/com.android.runtime/lib/bionic/libc.so at 0xf6a52000<br>malloc offset: 0x2d685<br>/apex/com.android.runtime/lib/bionic/libc.so at 0xeac4f000<br>malloc address: 0xeac7c685<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xf6a0c000<br>dlopen offset: 0x1849<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xe9f92000<br>dlopen address: 0xe9f93849<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xf6a0c000<br>dlerror offset: 0x1853<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xe9f92000<br>dlerror address: 0xe9f93853<br>attach to process pid: 21551<br>proc 0xeac7c685 param 0 value: 0x100<br>proc 0xeac7c685 return value: 0x7b4e0700<br>malloc memory at 0x7b4e0700<br>write 0x1b bytes, start-addr: 0x7b4e0700<br>proc 0xe9f93849 param 0 value: 0x7b4e0700<br>proc 0xe9f93849 param 1 value: 0x1<br>proc 0xe9f93849 return value: 0x0<br>dlopen load /data/local/tmp/libhook.so to process 21551 failed<br>proc 0xe9f93853 return value: 0xec8f6514<br>read 0x100 bytes, start-addr: 0xec8f6514<br>dlopen failed: couldn&#x27;t map &quot;/data/local/tmp/libhook.so&quot; segment 2: Permission denied<br></code></pre></td></tr></table></figure><p>根据打印信息，注入器在待注入进程中调用<code>malloc</code>方法成功分配了内存，但是调用<code>dlopen</code>返回值为<code>NULL</code>，加载so文件失败，调用<code>dlerror</code>查看到返回错误消息为<code>dlopen failed: couldn&#39;t map &quot;/data/local/tmp/libhook.so&quot; segment 2: Permission denied</code>，说明so路径写入正确，进一步尝试发现，该错误与SELinux有关，开启SELinux模式后，进程无法加载非系统lib目录下的so文件，关闭SELinux后进行注入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">lmipro:/data/local/tmp # getenforce                                                                                                                       <br>Enforcing<br>lmipro:/data/local/tmp # setenforce 0                                                                                                                     <br>lmipro:/data/local/tmp # getenforce                                                                                                                       <br>Permissive<br>lmipro:/data/local/tmp # ./injector com.example.crackme1 /data/local/tmp/libhook.so                                                                       <br>pid of com.example.crackme1: 21551<br>/apex/com.android.runtime/lib/bionic/libc.so at 0xf274d000<br>malloc offset: 0x2d685<br>/apex/com.android.runtime/lib/bionic/libc.so at 0xeac4f000<br>malloc address: 0xeac7c685<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xf270c000<br>dlopen offset: 0x1849<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xe9f92000<br>dlopen address: 0xe9f93849<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xf270c000<br>dlerror offset: 0x1853<br>/apex/com.android.runtime/lib/bionic/libdl.so at 0xe9f92000<br>dlerror address: 0xe9f93853<br>attach to process pid: 21551<br>proc 0xeac7c685 param 0 value: 0x100<br>proc 0xeac7c685 return value: 0x7b4e0800<br>malloc memory at 0x7b4e0800<br>write 0x1b bytes, start-addr: 0x7b4e0800<br>proc 0xe9f93849 param 0 value: 0x7b4e0800<br>proc 0xe9f93849 param 1 value: 0x1<br>proc 0xe9f93849 return value: 0x5fe6de0b<br>dlopen load /data/local/tmp/libhook.so to process 21551 succeed<br></code></pre></td></tr></table></figure><p>注入成功，查看<code>/proc/pid/maps</code>中模块加载信息</p><p><img src="2023-10-09-13-32-08-image.png"></p><p>libhook.so成功加载到进程内存</p><h3 id="4-inline-hook"><a href="#4-inline-hook" class="headerlink" title="4.inline hook"></a>4.inline hook</h3><p>根据提示，选择hook的函数为<code>proc</code>，偏移地址<code>0x1134</code>，此处选择使用inline hook的方式实现</p><p>首先在<code>libhook.c</code>文件中定义替代<code>proc</code>的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">hookProc</span><span class="hljs-params">()</span><br>&#123;<br>    LOGD(<span class="hljs-string">&quot;hook and return TRUE&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数打印log信息并返回1，使<code>stringFromJNI</code>函数返回<code>right</code></p><p>跳转到该函数使用如下汇编指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm6502">LDR R0, [PC+8]<br>MOV PC, R0<br>hookProc_addr<br></code></pre></td></tr></table></figure><p>跳转码共12个字节，将<code>hookProc</code>的地址先加载到R0寄存器，使用MOV指令修改PC寄存器到<code>hookProc</code>函数，由于<code>hookProc</code>函数的作用是代替<code>proc</code>执行，参数、返回值、返回地址均不需要额外处理</p><p>修改<code>libcrackme1.so</code>加载处内存的保护权限，将12个字节跳转码写入<code>proc</code>函数起始处，完成hook操作</p><p>so文件注入后的自动执行可以使用<code>__attribute__((constructor))</code>属性声明函数，该属性声明的函数会在dlopen函数返回前执行</p><p>设置hook的代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sethook</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 首先获取libcrackme1.so加载的基地址</span><br>    <span class="hljs-type">void</span> *lib_base = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> proc_offset = <span class="hljs-number">0x1134</span>;<br>    <span class="hljs-type">void</span> *proc_addr;<br>    FILE *fp;<br>    <span class="hljs-type">char</span> line[<span class="hljs-number">0x100</span>];<br>    fp = fopen(<span class="hljs-string">&quot;/proc/self/maps&quot;</span>, <span class="hljs-string">&quot;rt&quot;</span>);<br>    fgets(line, <span class="hljs-number">0x100</span>, fp);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">strlen</span>(line) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(line, <span class="hljs-string">&quot;libcrackme1.so&quot;</span>) != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">sscanf</span>(line, <span class="hljs-string">&quot;%lx&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*)&amp;lib_base);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        fgets(line, <span class="hljs-number">0x100</span>, fp);<br>    &#125;<br>    fclose(fp);<br>    <span class="hljs-keyword">if</span> (lib_base == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        LOGD(<span class="hljs-string">&quot;get libcrackme1.so base failed&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    LOGD(<span class="hljs-string">&quot;libcrackme1.so at 0x%lx&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)lib_base);<br>    proc_addr = (<span class="hljs-type">void</span> *)((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)lib_base + proc_offset);<br>    LOGD(<span class="hljs-string">&quot;hook proc at 0x%lx&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)proc_addr);<br>    LOGD(<span class="hljs-string">&quot;new proc at 0x%lx&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)hookProc);<br>    <span class="hljs-comment">// LDR R0, [PC+8]</span><br>    <span class="hljs-comment">// MOV PC, R0</span><br>    <span class="hljs-comment">// hookProc</span><br>    <span class="hljs-comment">// 修改段保护</span><br>    <span class="hljs-keyword">if</span> (mprotect(lib_base, <span class="hljs-number">0x2000</span>, PROT_READ | PROT_WRITE | PROT_EXEC) != <span class="hljs-number">0</span>)<br>    &#123;<br>        LOGD(<span class="hljs-string">&quot;mprotect failed&quot;</span>);<br>        perror(<span class="hljs-string">&quot;mprotect&quot;</span>);<br>        LOGD(<span class="hljs-string">&quot;Error: %s\n&quot;</span>, strerror(errno));<br>    &#125;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> jumpCode[<span class="hljs-number">0xc</span>] = &#123;<span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x9F</span>, <span class="hljs-number">0xE5</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0xE1</span>&#125;;<br>    *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)(jumpCode + <span class="hljs-number">8</span>) = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)hookProc;<br>    __memcpy(proc_addr, (<span class="hljs-type">void</span> *)jumpCode, <span class="hljs-number">0xc</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>设置log和so入口函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">onload</span><span class="hljs-params">()</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((constructor))</span>;<br><br><span class="hljs-type">void</span> (*__android_log_print)(<span class="hljs-type">int</span> i, ...);<br><span class="hljs-type">void</span> *handle;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TAG <span class="hljs-string">&quot;Crack&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOGD(...) __android_log_print(3, TAG, __VA_ARGS__)  </span><br><span class="hljs-type">void</span> *(*__memcpy)(<span class="hljs-type">void</span> *dst, <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> n);<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">onload</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 设置LOGD</span><br>    handle = dlopen(<span class="hljs-string">&quot;/system/lib/liblog.so&quot;</span>, RTLD_LAZY);<br>    __android_log_print = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">int</span>, ...))dlsym(handle, <span class="hljs-string">&quot;__android_log_print&quot;</span>);<br>    dlclose(handle);<br>    <span class="hljs-comment">// 获取memcpy</span><br>    handle = dlopen(<span class="hljs-string">&quot;/apex/com.android.runtime/lib/bionic/libc.so&quot;</span>, RTLD_LAZY);<br>    __memcpy = (<span class="hljs-type">void</span> *(*)(<span class="hljs-type">void</span> *, <span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span>))dlsym(handle, <span class="hljs-string">&quot;memcpy&quot;</span>);<br>    dlclose(handle);<br><br>    LOGD(<span class="hljs-string">&quot;injected by noxke&quot;</span>);<br>    sethook();<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的<code>__android_log_print</code>和<code>memcpy</code>需要使用<code>dlopen</code>和<code>dlsym</code>获取</p><p>编译hook代码，上传并注入到<code>com.example.crackme1</code>进程中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">armv7a-linux-androideabi33-clang libhook.c -shared -fPIC -o libhook.so<br>❯ adb push libhook.so /data/local/tmp/<br>libhook.so: 1 file pushed, 0 skipped. 106.0 MB/s (7180 bytes in 0.000s)<br><br>❯ adb shell<br>lmipro:/ $ cd /data/local/tmp<br>lmipro:/data/local/tmp $ su<br>lmipro:/data/local/tmp # ./injector com.example.crackme1 /data/local/tmp/libhook.so<br></code></pre></td></tr></table></figure><p>使用logcat查看log信息</p><p><img src="2023-10-09-13-46-53-image.png"></p><p>随意输入字符串，点击确定按钮</p><img src="2023-10-09-13-47-45-image.png" title="" alt="" width="216"><p>logcat打印日志</p><p><img src="2023-10-09-13-48-34-image.png"></p><p>hook结果与所需结果相同，<code>proc</code>代码的调用会被跳转到<code>hookProc</code>执行并返回，<code>stringFromJNI</code>返回<code>right</code>字符串</p><p>使用ida查看修改后的<code>proc</code>函数和<code>hookProc</code>函数</p><img src="2023-10-09-13-51-27-image.png" title="" alt="" width="492"><img src="2023-10-09-13-52-02-image.png" title="" alt="" width="489">]]></content>
    
    
    <categories>
      
      <category>腾讯游戏客户端安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动端调试环境搭建</title>
    <link href="/2023/10/02/TencentGameClient/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/10/02/TencentGameClient/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>本篇将介绍安卓软件Java层和Native层调试工具的安装和简单使用</p><p>涉及到的软件如下</p><p><a href="https://developer.android.google.cn/studio?hl=zh-cn">Android studio</a></p><p><a href="https://github.com/skylot/jadx">jadx</a></p><p><a href="https://hex-rays.com/IDA-pro/">Ida Pro</a></p><h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><blockquote><p>jadx和Ida的安装使用都很简单，此处不做介绍，安装Android studio过程需要确保有正常的网络环境，网络配置不做介绍</p></blockquote><ol><li><p>插件安装</p><p><a href="https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack----/versions#tabs">Chinese (Simplified) Language Pack &#x2F; 中文语言包 - IntelliJ IDEs Plugin | Marketplace</a></p><p><a href="https://github.com/JesusFreke/smalidea">GitHub - JesusFreke&#x2F;smalidea: smalidea is a smali language plugin for IntelliJ IDEA</a></p></li><li><p>SDK安装</p><p>打开SDK Manager，修改sdk目录，安装如下SDK工具</p><p><img src="2023-10-06-01-08-30-image.png"></p></li><li><p>添加环境变量</p><p>将<code>$sdkPath/platform-tools/</code></p><p><code>$sdkPath//opt/android-studio-sdk/ndk/26.0.10792818/toolchains/llvm/prebuilt/linux-x86_64/bin/</code>添加到环境变量，ndk变量需要根据自己的环境情况进行添加</p></li><li><p>创建Android Virtual Device(AVD)虚拟机</p><p>打开Virtual Device Manager</p><p>选择创建，按照个人习惯，机型选择<code>Pixel XL</code>，镜像选择<code>Oreo</code>(API27 x86 Android 8.1)，如果是64位环境，选择<code>Tiramisu</code>(API33 x86_64 Android 13.0)</p></li></ol><p>   将Device Frame的勾取消，点击完成即可创建</p><h4 id="Android-Studio调试"><a href="#Android-Studio调试" class="headerlink" title="Android Studio调试"></a>Android Studio调试</h4><p>选择右图<code>Profile or Debug APK</code></p><p><img src="2023-10-06-01-20-26-image.png"></p><p>有可能打开后和左图一样，没有<code>Profile or Debug APK</code>选项，如果出现该情况，进入到插件设置，启用Android APK Support和Android NDK Support并重启Android Studio</p><img src="2023-10-06-01-22-03-image.png" title="" alt="" width="573"><p>选择<code>Profile or Debug APK</code>后，选中需要调试的apk文件</p><p><img src="2023-10-06-01-25-31-image.png"></p><p>左侧选择java并找到要调试的类，打开编译后的smali代码，对smali代码不了解的可以使用jadx工具对照查看反编译的java代码</p><p><img src="2023-10-06-01-28-14-image.png"></p><blockquote><p>虽然jadx也可以进行动态调试，但不推荐，很多情况下无法看到寄存器的值</p></blockquote><p>选择调试的AVD虚拟机并编辑调试配置文件</p><p><img src="2023-10-06-01-29-30-image.png"></p><p>将Debuger类型修改为Java Only，不修改的情况下会默认附加lldb调试器，导致ida调试器无法附加</p><img src="2023-10-06-01-30-49-image.png" title="" alt="" width="523"><p>在Device Manager中启动AVD虚拟机</p><p><img src="2023-10-06-01-33-43-image.png"></p><p>下断点并点击调试</p><p><img src="2023-10-06-01-34-24-image.png"></p><p><img src="2023-10-06-01-35-02-image.png"></p><p>正常情况下程序会断下并进入调试状态，但有时会出现无法调试的情况，如果发生该情况，到插件管理禁用Android APK Support和Android NDK Support(可不进行重启)</p><p>剩下的调试部分不做介绍</p><h4 id="Ida调试"><a href="#Ida调试" class="headerlink" title="Ida调试"></a>Ida调试</h4><p>确保上述操作AVD虚拟机启动和软件进入调试状态</p><p>提取程序的lib文件(使用unzip解压apk文件，在lib目录中找到对于处理器架构的so文件)</p><p>将Ida的dbgsrv目录下的对应架构的调试服务器上传到AVD虚拟机中，例如本题为<code>android_x86_server</code>，开启29346端口转发(开启转发失败时去掉-s选项)</p><p><img src="2023-10-06-01-50-32-image.png"></p><p>adb shell进入到AVD虚拟机的命令行，su切换到root权限，进入dbgsrv目录</p><p><img src="2023-10-06-01-43-05-image.png"></p><p>为<code>android_x86_server</code>添加可执行权限并运行</p><p><img src="2023-10-06-01-44-19-image.png"></p><p>启动ida32并选择要调试的so文件(不建议修改文件名)</p><p>找到需要调试的函数下断点</p><p>选择调试器为<code>Remote Linux debugger</code></p><p><img src="2023-10-06-01-47-07-image.png"></p><p>Debugger-&gt;Process Option设置Hostname为<code>127.0.0.1</code></p><img src="2023-10-06-01-49-22-image.png" title="" alt="" width="500"><p>Debugger-&gt;Attach to process选择要调试的进程</p><img src="2023-10-06-01-55-00-image.png" title="" alt="" width="500"><p>出现询问模块名相同选择<code>Same</code></p><img src="2023-10-06-01-55-55-image.png" title="" alt="" width="507"><p>Ida附加后会自动断下，按F9运行一次</p><p>回到Android Studio单步执行native函数，Ida会在断点处断下</p><p>剩下的调试部分不做介绍</p>]]></content>
    
    
    <categories>
      
      <category>腾讯游戏客户端安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游戏客户端开发基础-移动篇(视频习题)</title>
    <link href="/2023/10/02/TencentGameClient/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-%E7%A7%BB%E5%8A%A8%E7%AF%87(%E8%A7%86%E9%A2%91%E4%B9%A0%E9%A2%98)/"/>
    <url>/2023/10/02/TencentGameClient/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-%E7%A7%BB%E5%8A%A8%E7%AF%87(%E8%A7%86%E9%A2%91%E4%B9%A0%E9%A2%98)/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/noxke/TencentGameClientOpenCourse">GitHub - noxke&#x2F;TencentGameClientOpenCourse: 腾讯游戏客户端公开课2023 腾讯菁英班</a></p><h3 id="1-静态分析"><a href="#1-静态分析" class="headerlink" title="1.静态分析"></a>1.静态分析</h3><h4 id="Java层"><a href="#Java层" class="headerlink" title="Java层"></a>Java层</h4><p>使用jadx打开题目<code>gslab.demo.apk</code>文件，查看<code>AndroidManifest.xml</code>文件获取软件入口activity为<code>com.example.x86demo.MainActivity</code></p><p>查看该入口activity类的<code>onCreate</code>方法</p><p><img src="2023-10-05-22-42-18-image.png"></p><p>TextView对象<code>tv</code>设置的字符串来自<code>stringFromJNI</code>方法</p><p><img src="2023-10-05-22-43-55-image.png"></p><p>查看其余部分，<code>stringFromJNI</code>是<code>native-lib</code>中的native函数</p><h4 id="Native层"><a href="#Native层" class="headerlink" title="Native层"></a>Native层</h4><p>该软件提供了<code>armabi-v7a</code>和<code>x86</code>两种处理器架构的<code>libnative-lib.so</code>文件，此处对arm架构so文件进行分析</p><p>使用readelf命令查看<code>libnative-lib.so</code>的导出函数</p><img src="2023-10-05-22-50-46-image.png" title="" alt="" width="527"><p><code>stringFromJNI</code>导出函数的偏移地址为<code>0x08bdd</code>，完整导出名称为<code>Java_com_example_x86demo_MainActivity   _stringFromJNI</code></p><blockquote><p>arm指令集每条指令长度为32位，存在指令对其，指令地址低两位均为0，而此处偏移地址最低位为1，表示处理器执行到该处时进入Thumb模式，指令长度变为16位或32位，实际指令偏移地址为<code>0x8bdc</code></p></blockquote><p>使用ida32打开<code>libnative-lib.so</code>文件，定位到导出函数，指令长度大多为16位，表示处理器执行该函数时处于Thumb模式</p><p>反编译查看该函数</p><img src="2023-10-05-22-58-44-image.png" title="" alt="" width="527"><p>程序使用C++的string类构造string对象并返回，注意到除了<code>sub_E36E2CA6</code>函数外其它函数均为库函数，因此选择该函数进行hook</p><h3 id="2-动态调试"><a href="#2-动态调试" class="headerlink" title="2.动态调试"></a>2.动态调试</h3><blockquote><p>使用真机(android 13)进行调试，调试工具为android studio和ida</p></blockquote><h4 id="Java层-1"><a href="#Java层-1" class="headerlink" title="Java层"></a>Java层</h4><p>对<code>stringFromJNI</code>调用处的smali代码下断点，连接设备进行调试</p><img src="2023-10-05-23-06-29-image.png" title="" alt="" width="533"><p>程序在断点处断下，单步跳过查看<code>stringFromJNI</code>函数的返回值(v1寄存器)</p><img title="" src="2023-10-05-23-08-51-image.png" alt="" width="533"><p>函数返回结果为字符串对象<code>Hello from C++</code></p><p>继续运行程序，屏幕显示<code>Hello from C++</code>字符串</p><h4 id="Native层-1"><a href="#Native层-1" class="headerlink" title="Native层"></a>Native层</h4><p>开启adb端口转发，将ida的dbgsrv上传到手机，进入shell切换到root权限启动dbgsrv</p><p><img src="2023-10-05-23-17-30-image.png"></p><p>android studio上开启调试，程序在smali代码断下</p><p>ida对<code>stringFromJNI</code>函数下断点，连接调试器并附加到<code>com.example.x86demo</code>进程，按F9继续运行</p><img src="2023-10-05-23-18-48-image.png" title="" alt="" width="532"><p>android studio单步执行，ida上程序在<code>stringFromJNI</code>函数断下</p><img src="2023-10-05-23-20-56-image.png" title="" alt="" width="507"><blockquote><p>此处处理器处于Thumb模式</p></blockquote><p>断点到<code>sub_E3722CA6</code>函数内部</p><img src="2023-10-05-23-22-52-image.png" title="" alt="" width="505"><p>函数只做了参数传递并调用<code>sub_E3723258</code>函数，<code>sub_E3722CA6</code>的参数为<code>R0</code>寄存器，值为<code>0xFF98C0E8</code>，显然为一个地址，跳转到该地址处</p><img src="2023-10-05-23-26-11-image.png" title="" alt="" width="513"><p>猜测该位置为一个结构体，结构体第一个整数为0x11，第二个整数为0x0E，第三个整数为<code>0x77EB6850</code>，第三个数明显为地址，跳转到该地址处</p><img src="2023-10-05-23-28-16-image.png" title="" alt="" width="509"><p>该地址处为字符串<code>Hello from C++</code>，对该字符串进行修改测试</p><img src="2023-10-05-23-29-30-image.png" title="" alt="" width="511"><p>ida使用F9运行，android studio单步断下，查看<code>stringFromJNI</code>返回值</p><img src="2023-10-05-23-30-42-image.png" title="" alt="" width="509"><p>返回值变为了上面修改的字符串，继续运行程序，屏幕上显示修改后的字符串</p><img src="2023-10-05-23-32-24-image.png" title="" alt="" width="451"><h3 id="3-使用ptrace注入并hook程序"><a href="#3-使用ptrace注入并hook程序" class="headerlink" title="3.使用ptrace注入并hook程序"></a>3.使用ptrace注入并hook程序</h3><blockquote><p>上述分析中选择<code>sub_E36E2CA6</code>函数进行hook，该函数偏移为<code>0x8ca6</code>，后续称为<code>proc</code></p><p>该函数的调用关系为<code>onCreate-&gt;stringFromJNI-&gt;proc</code>，由于该函数在程序启动时执行，几乎没有等待时间，所以在正常执行的情况下不能够保证100%hook成功</p></blockquote><p>本题使用traphook的方式修改proc函数的参数，思路如下：</p><ol><li><p>ptrace在proc函数开始位置设置软件断点</p></li><li><p>waitpid捕获进程停止信息</p></li><li><p>ptrace获取proc函数参数R0寄存器，得到字符串地址</p></li><li><p>ptrace修改字符串地址处的字符串</p></li><li><p>ptrace禁用断点，恢复程序执行</p></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>ptrace函数需要待附加进程的pid，使用<code>pidof com.example.x86demo</code>命令可以获得软件的<code>pid</code></p><p>想要hook <code>proc</code>函数，需要知道其内存中的加载地址，在静态分析中得到了其偏移地址<code>proc_offset = 0x8ca6</code>，还需要<code>libnative-lib.so</code>文件加载的基地址才能计算出<code>proc</code>函数的地址，安卓进程加载的库文件信息可以在<code>/proc/pid/maps</code>文件中找到</p><img src="2023-10-06-00-03-12-image.png" title="" alt="" width="581"><p>如图，本次程序运行<code>libnative-lib.so</code>的加载地址为<code>lib_base = e381d000</code>，<code>proc</code>函数的地址为<code>proc_addr = lib_base + proc_offset</code></p><p>c语言中使用popen函数执行命令行目录并获取结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取进程pid和libnative-lib.so加载的基地址</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>    fp = popen(<span class="hljs-string">&quot;pidof com.example.x86demo &amp;&amp; cat /proc/`pidof com.example.x86demo`/maps | grep libnative-lib.so&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    fread(cli_output, <span class="hljs-number">1</span>, <span class="hljs-number">1024</span>, fp);<br>    pclose(fp);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(cli_output) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">sscanf</span>(cli_output, <span class="hljs-string">&quot;%d%lx&quot;</span>, &amp;demo_pid, &amp;lib_base);<br>        <span class="hljs-keyword">if</span> (lib_base == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;demo_pid: %d\n&quot;</span>, demo_pid);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;libnative-lib.so image base: 0x%lx\n&quot;</span>, lib_base);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="2023-10-06-00-06-29-image.png"></p><p>使用ptrace附加到进程并将<code>proc</code>函数第一条指令修改为软件断点，设置断点前需要保存原始指令，确保后续能够使程序正确运行，设置断点后恢复进程运行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bp_code = <span class="hljs-number">0x0000BEFF</span>;  <span class="hljs-comment">// 设置FF号断点</span><br><span class="hljs-comment">// 需要hook的函数偏移</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> proc_offset = <span class="hljs-number">0x8ca6</span>;<br><span class="hljs-comment">// 需要hook的函数地址</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> proc_addr = lib_base + proc_offset;<br>    <span class="hljs-comment">// 附加到目标进程</span><br>ptrace(PTRACE_ATTACH, pid, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>waitpid(pid, &amp;status, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 先保存断点前的指令，再将其设置为断点代码</span><br>ori_code = ptrace(PTRACE_PEEKDATA, pid, (<span class="hljs-type">void</span> *)proc_addr, <span class="hljs-literal">NULL</span>);<br>ptrace(PTRACE_POKEDATA, pid, (<span class="hljs-type">void</span> *)proc_addr, (<span class="hljs-type">void</span> *)bp_code);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set breakpoint at 0x%lx\n&quot;</span>, proc_addr);<br>ptrace(PTRACE_CONT, pid, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>当处理器执行到软件断点时会发出<code>SIGTRAP</code>信号，使用waitpid捕获断点信号，并获取寄存器信息，判断PC寄存器地址是否为断点地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 捕获断点</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>    waitpid(pid, &amp;status, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (WIFSTOPPED(status) &amp;&amp; WSTOPSIG(status) == SIGTRAP)<br>    &#123;<br>        <span class="hljs-comment">// 获取寄存器信息</span><br>        ptrace(PTRACE_GETREGS, pid, <span class="hljs-literal">NULL</span>, &amp;regs);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pc = regs.uregs[<span class="hljs-number">15</span>];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;break at 0x%lx\n&quot;</span>, pc);<br>        <span class="hljs-keyword">if</span> (pc == proc_addr)<br>        &#123;<br>            <span class="hljs-comment">// hook操作</span><br>        &#125;<br>    &#125;<br>    ptrace(PTRACE_CONT, pid, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当程序在设置的断点处断下后，寄存器R0的值为proc函数的参数，其值为地址，<code>R0+8</code>为字符串地址，使用ptrace修改<code>R0+8</code>处的字符串，实现对<code>stringFromJNI</code>返回值的修改</p><p>完成修改后需要将断点恢复为原始指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取R0寄存器</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> r0 = regs.uregs[<span class="hljs-number">0</span>];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> str_addr = ptrace(PTRACE_PEEKDATA, pid, (<span class="hljs-type">void</span> *)(r0 + <span class="hljs-number">8</span>), <span class="hljs-literal">NULL</span>);<br><span class="hljs-type">char</span> ori_str[<span class="hljs-number">0x20</span>];<br><span class="hljs-type">char</span> new_str[<span class="hljs-number">0x20</span>];<br><span class="hljs-built_in">strcpy</span>(new_str, hack_str);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x20</span>; i += <span class="hljs-number">4</span>)<br>&#123;<br>    *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)(ori_str + i) = ptrace(PTRACE_PEEKDATA, pid, (<span class="hljs-type">void</span> *)(str_addr + i), <span class="hljs-literal">NULL</span>);<br>    ptrace(PTRACE_POKEDATA, pid, (<span class="hljs-type">void</span> *)(str_addr + i), (<span class="hljs-type">void</span> *)(*(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)(new_str + i)));<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str at 0x%lx\n&quot;</span>, str_addr);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ori str: %s\n&quot;</span>, ori_str);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new str: %s\n&quot;</span>, new_str);<br><span class="hljs-comment">// 恢复原来的指令</span><br>ptrace(PTRACE_POKEDATA, pid, (<span class="hljs-type">void</span> *)proc_addr, (<span class="hljs-type">void</span> *)ori_code);<br></code></pre></td></tr></table></figure><p>编译程序并上传到手机测试</p><p><img src="2023-10-06-00-21-03-image.png"></p><img src="2023-10-06-00-22-22-image.png" title="" alt="" width="296"><blockquote><p>x86的hook实现与arm的实现基本相同，除了<code>proc</code>函数的偏移地址不同，以及断点指令不同以外，还需要注意x86处理器在执行int3断点后会将EIP+1，捕获断点后除了将断点指令恢复，还需要将EIP寄存器恢复</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>腾讯游戏客户端安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游戏客户端开发基础-PC篇</title>
    <link href="/2023/09/26/TencentGameClient/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-PC%E7%AF%87/"/>
    <url>/2023/09/26/TencentGameClient/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-PC%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/noxke/TencentGameClientOpenCourse">GitHub - noxke&#x2F;TencentGameClientOpenCourse: 腾讯游戏客户端公开课2023 腾讯菁英班</a></p><h3 id="1-程序分析"><a href="#1-程序分析" class="headerlink" title="1.程序分析"></a>1.程序分析</h3><p>使用ida打开crackme.exe，进入到程序的主逻辑函数，注意到有大量的xmm寄存器，但是不含call指令，先忽略，注意到两个特殊部分：</p><p><img src="pic2.png"></p><p>左图中调用了CreateThread函数创建子线程运行StartAddress处函数，右侧含有分支判断，完成判断后sleep并返回，猜测该处与程序的判断逻辑有关</p><p>F5查看反编译代码</p><img src="pic3.png" title="" alt="" width="396"><p>末尾进行了数据串的比较，后根据比较结果为v32地址处的4个字节赋值，紧接着两个字节赋值<code>0x0a,0x0d</code>，换行回车符号，猜测v32地址处为输出字符串，结合测试时的输出<code>错误</code>，猜测<code>0xCBF9DBB4 0x8FFFCBD5</code>经过异或后为gbk编码格式的字符串，在线编码工具测试，猜测成立</p><img src="pic4.png" title="" alt="" width="485"><p>显然，v37处储存的内容影响最后的输出结果，对<code>v32=v37</code>下断点启动调试，随意输入字符串后在该处断下，查看v32内容</p><p><img src="pic5.png"></p><p>显然, v37为输入的原内容，根据比较部分可以得知，<code>v37-48</code>处为flag</p><p><img src="pic6.png"></p><p>得到程序flag<code>HiGWDUuXQS6wVHBTp0ERfJe6VqprMqD1</code></p><img src="pic7.png" title="" alt="" width="404"><p>分析剩余部分得到程序的输入函数和输出函数，后续将称其为<code>printf scanf</code></p><p><img src="pic8.png"></p><h3 id="2-DLL注入分析"><a href="#2-DLL注入分析" class="headerlink" title="2.DLL注入分析"></a>2.DLL注入分析</h3><p>题目要求使用<code>CreateRemoteThread</code>api进行注入</p><blockquote><p>最基础的代码注入方式, 使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread"><code>CreateRemoteThread</code></a>在目标进程下创建远程线程, 调用<a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya"><code>LoadLibraryA</code></a>加载DLL到目标进程, DLL加载&#x2F;卸载时调用<code>DllMain</code>函数, 执行注入DLL中的代码, <code>LoadLibraryA</code>参数需要先写入目标进程的内存, 使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex"><code>VirtualAllocEx</code></a>在目标进程内存下分配内存, 使用<a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory"><code>WriteProcessMemory</code></a>将需要注入的DLL地址写入目标内</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID);<br>pRemoteBuf = VirtualAllocEx(hProcess, <span class="hljs-literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);<br>WriteProcessMemory(hProcess, pRemoteBuf, dllPath, dwBufSize, <span class="hljs-literal">NULL</span>);<br>hMod = GetModuleHandleA((LPCSTR)<span class="hljs-string">&quot;kernel32.dll&quot;</span>);<br>pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="hljs-string">&quot;LoadLibraryA&quot;</span>);<br>CreateRemoteThread(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, pThreadProc, pRemoteBuf, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><blockquote><p>创建远程线程时传入的<code>LoadLibraryA</code>地址并不是直接获取目标进程中的函数地址, 因为系统DLL在不同进程中加载地址相同</p></blockquote><p>编写一个输出字符串的DLL进行注入测试<br><img title="" src="pic9.png" alt="" width="359"></p><p><img src="pic10.png"></p><p>注入creackme.exe失败，但注入其他程序正常，重新分析代码，分析<code>CreateThread</code>函数创建的线程执行的<code>StartAddress</code>处代码，找到关键位置</p><p><img src="pic11.png"></p><p>此处将<code>LoadLibraryExW</code>函数的内存权限修改为可写入，然后将第一个字节patch成-61（0xC3, ret指令），将指令第一行修改为ret指令，将<code>LoadLibraryExW</code>函数patch掉了，因此<code>LoadLibraryA</code>函数也无法正常使用</p><p><img src="pic12.png"></p><p>不过中间有10秒的sleep,在启动后就注入即可</p><p><img src="pic13.png"></p><h3 id="3-hook代码"><a href="#3-hook代码" class="headerlink" title="3.hook代码"></a>3.hook代码</h3><p>将输出结果修改称正确，patch一下分支语句或者将错误的gbk编码patch成正确就可以，但是题目要求用DLL注入hook程序，因此此处用注入的DLL修改程序，hook掉<code>printf</code>函数，思路如下</p><blockquote><p>将<code>printf</code>前几行指令修改为跳转指令，跳转到注入的shellcode中，在shellcode中判断<code>printf</code>的参数（即待输出的字符串）是否为<code>错误</code>，如果为<code>错误</code>，将其修改为<code>正确</code>，替换完成后在shellcode中执行<code>printf</code>前几行被替换的指令，然后返回到<code>printf</code>函数继续执行，输出修改后的字符串</p></blockquote><p>printf修改前后代码:</p><img src="pic14.png" title="" alt="" width="528"><p>修改前前4条指令为将寄存器参数压入堆栈，此处将其修改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nasm">mov eax, $shellcode<br>push rax<br>ret<br></code></pre></td></tr></table></figure><p>将shellcode的地址压入堆栈中，使用ret指令跳转到shellcode代码出，shellcode代码如下（前后填充的nop省略）</p><img src="pic15.png" title="" alt="" width="521"><p>主要代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nasm">mov eax, [rcx]         ; 将printf第一个参数(输出字符串)的前四个字节传送到eax<br>cmp eax, 0xF3CEEDB4    ; 判断这四个字节是否为错误两个字的gbk编码<br>jne $+0x8              ; 不是错误两个字的gbk编码则跳过接下来两条指令<br>mov eax, 0xB7C8FDD5    ; 如果是错误两个字的gbk编码，将其修改为正确两个字的gbk编码<br>mov [rcx], eax         ; 将这四个字节写回输出字符串，完成替换<br>;原printf函数前4条指令    ; 为printf完成参数压栈<br>mov rax, $printf+0x20  ; printf的指令位置，跳过修改的代码<br>push rax               ; push ret压栈返回<br>ret<br></code></pre></td></tr></table></figure><p>只需要在注入的DLL中计算printf的地址，将地址写入shellcode,将shellcode写入可执行内存，再hook掉printf的代码即可完成修改操作</p><p>设置hook代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">set_hook</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// hook printf函数</span><br>    DWORD64 pProc;<br>    DWORD64 pProcOffset = <span class="hljs-number">0x1020</span>;<br>    HMODULE hModule = GetModuleHandle(nullptr);<br>    DWORD_PTR baseAddress = reinterpret_cast&lt;DWORD_PTR&gt;(hModule);<br>    pProc = (DWORD64)baseAddress + pProcOffset;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nhook proc addr : 0x%llx\n&quot;</span>, pProc);<br>    <span class="hljs-comment">// 修改shellcode中的返回地址 printf+0x10</span><br>    *((DWORD64 *)((<span class="hljs-type">uint8_t</span> *)shellcode + <span class="hljs-number">0x50</span> - <span class="hljs-number">0x1A</span>)) = (pProc + <span class="hljs-number">0x10</span>);<br>    <span class="hljs-comment">// 写入shellcode</span><br>    LPVOID shellcodeBuf = VirtualAlloc(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0x50</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(shellcodeBuf, shellcode, <span class="hljs-number">0x50</span>);<br>    DWORD64 dwShellcodeBuf = (DWORD64)shellcodeBuf;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nshell code addr : 0x%llx\n&quot;</span>, dwShellcodeBuf);<br>    <span class="hljs-comment">// 修改函数内存保护权限</span><br>    VirtualProtect((LPVOID)pProc, <span class="hljs-number">20</span>, PAGE_EXECUTE_READWRITE, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 修改hookcode中的shellcode地址</span><br>    *((DWORD64 *)((<span class="hljs-type">uint8_t</span> *)hookcode + <span class="hljs-number">6</span>)) = dwShellcodeBuf;<br>    <span class="hljs-comment">// 获取进程句柄</span><br>    HANDLE hProcess = GetCurrentProcess();<br>    <span class="hljs-comment">// hook printf函数</span><br>    WriteProcessMemory(hProcess, (LPVOID)pProc, hookcode, <span class="hljs-number">20</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于PE文件加载时会进行重定向操作，所以printf函数的地址不固定，需要通过PE文件加载的基地址+函数偏移量得到printf函数的准确地址，另外shellcode需要申请可执行内存块确保指令可以正常执行，需要修改printf函数的内存块可写，修改其前几行指令</p><p>注入后运行程序，任意输入均返回正确e</p>]]></content>
    
    
    <categories>
      
      <category>腾讯游戏客户端安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
